<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SchuimSurfer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f9fafb;
      height: 100vh;
      overflow: hidden;
    }

    .container { display: flex; flex-direction: column; height: 100vh; }

    .header {
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 1rem 1.5rem;
    }

    .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }

    h1 { font-size: 1.5rem; color: #111827; margin-bottom: 0.25rem; }

    .subtitle { font-size: 0.875rem; color: #6b7280; }

    .upload-btn {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.625rem 1rem; background: #2563eb; color: white;
      border: none; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: background 0.2s;
    }
    .upload-btn:hover { background: #1d4ed8; }

    .stats-grid {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem; margin-bottom: 1rem;
    }

    .stat-card { padding: 0.75rem; border-radius: 0.5rem; }
    .stat-card.blue { background: #eff6ff; }    .blue .stat-label { color: #2563eb; }    .blue .stat-value { color: #1e3a8a; }
    .stat-card.purple { background: #f5f3ff; }  .purple .stat-label { color: #7c3aed; }  .purple .stat-value { color: #5b21b6; }
    .stat-card.green { background: #f0fdf4; }   .green .stat-label { color: #059669; }   .green .stat-value { color: #065f46; }
    .stat-card.orange { background: #fff7ed; }  .orange .stat-label { color: #ea580c; }  .orange .stat-value { color: #9a3412; }
    .stat-card.gray { background: #f3f4f6; }    .gray .stat-label { color: #4b5563; }    .gray .stat-value { color: #1f2937; }
    .stat-card.pink { background: #fdf2f8; }    .pink .stat-label { color: #db2777; }    .pink .stat-value { color: #9f1239; }
    .stat-card.yellow { background: #fefce8; }  .yellow .stat-label { color: #ca8a04; }  .yellow .stat-value { color: #854d0e; }
    .stat-card.cyan { background: #ecfeff; }    .cyan .stat-label { color: #0891b2; }    .cyan .stat-value { color: #155e75; }
    .stat-card.red { background: #fef2f2; }     .red .stat-label { color: #dc2626; }     .red .stat-value { color: #991b1b; }

    .stat-label {
      font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.25rem;
    }
    .stat-value { font-size: 1.5rem; font-weight: 700; }

    .main-content { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 340px; background: white; border-right: 1px solid #e5e7eb; padding: 1.5rem; overflow-y: auto; }

    .control-group { margin-bottom: 1.5rem; }
    .control-label {
      display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem;
    }
    select, input[type="text"], input[type="date"], input[type="range"], input[type="number"] {
      width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem;
    }
    select:focus, input:focus { outline: none; border-color: #2563eb; box-shadow: 0 0 0 3px rgba(37,99,235,0.1); }

    .date-range { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .date-input-wrapper { display: flex; flex-direction: column; gap: 0.25rem; }
    .date-label { font-size: 0.75rem; color: #6b7280; }
    .range-value { font-size: 0.875rem; color: #6b7280; margin-top: 0.25rem; }

    .btn {
      width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;
      padding: 0.625rem 1rem; border: none; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background 0.2s;
    }
    .btn-export { background: #059669; color: white; } .btn-export:hover:not(:disabled) { background: #047857; }
    .btn-detect { background: #7c3aed; color: white; margin-bottom: 0.5rem; } .btn-detect:hover:not(:disabled) { background: #6d28d9; }
    .btn-cib { background: #dc2626; color: white; margin-bottom: 1rem; } .btn-cib:hover:not(:disabled) { background: #b91c1c; }
    .btn:disabled { background: #d1d5db; cursor: not-allowed; }

    .info-panel { background: #f9fafb; padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
    .info-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem; }
    .info-title { font-weight: 600; color: #111827; }
    .close-btn { background: none; border: none; cursor: pointer; color: #6b7280; padding: 0; }
    .info-row { font-size: 0.875rem; margin-bottom: 0.5rem; }
    .info-label { color: #6b7280; }
    .info-value { font-weight: 500; }

    .legend { background: #f9fafb; padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
    .legend-title { font-weight: 600; color: #111827; margin-bottom: 0.75rem; }
    .legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; margin-bottom: 0.5rem; }
    .legend-dot { width: 1rem; height: 1rem; border-radius: 50%; }
    .legend-note { font-size: 0.75rem; color: #6b7280; margin-top: 0.75rem; }

    .canvas-container { flex: 1; background: white; position: relative; }
    #network-canvas { width: 100%; height: 100%; cursor: pointer; }
    #network-canvas.hovering { cursor: pointer; }

    .empty-state {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;
    }
    .empty-icon { width: 48px; height: 48px; margin: 0 auto 1rem; color: #9ca3af; }
    .empty-title { font-size: 1.25rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem; }
    .empty-text { color: #6b7280; }

    .loading {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.5);
      display: none; align-items: center; justify-content: center; z-index: 1000; flex-direction: column;
    }
    .loading.active { display: flex; }
    .spinner { width: 50px; height: 50px; border: 4px solid #f3f4f6; border-top: 4px solid #2563eb; border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 1rem; }
    .loading-text { color: white; font-size: 1rem; font-weight: 500; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    input[type="file"] { display: none; }

    .metrics-list { list-style: none; }
    .metrics-list li {
      display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #e5e7eb; font-size: 0.875rem;
    }
    .metrics-list li:last-child { border-bottom: none; }
    .metric-name { color: #6b7280; }
    .metric-value { font-weight: 600; color: #111827; }

    .section-divider { height: 1px; background: #e5e7eb; margin: 1.5rem 0; }

    .warning-box { background: #fef2f2; border: 1px solid #fecaca; border-radius: 0.5rem; padding: 0.75rem; margin-top: 0.5rem; }
    .warning-box p { font-size: 0.75rem; color: #991b1b; line-height: 1.4; }
    .cib-indicator { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: white; background: #dc2626; }
    .cib-score { font-weight: 700; color: #dc2626; }

    .small { font-size: 12px; color: #374151; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-top">
        <div>
          <h1>Zeeschuim Surfer</h1>
          <div class="subtitle">
            Basic network analysis and CIB detection
            <span id="platform-indicator" style="margin-left:0.5rem; opacity:0.7;"></span>
            <span id="rendering-indicator" style="margin-left:0.5rem; opacity:0.7; font-size:0.75rem;"></span>
          </div>
        </div>
        <label class="upload-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <span>Upload Zeeschuimer data (ndjson)</span>
          <input type="file" accept=".ndjson,.json" id="file-input">
        </label>
      </div>

      <div class="stats-grid" id="stats" style="display: none;">
        <div class="stat-card blue"><div class="stat-label">Posts</div><div class="stat-value" id="stat-posts">0</div></div>
        <div class="stat-card purple"><div class="stat-label">Users</div><div class="stat-value" id="stat-users">0</div></div>
        <div class="stat-card green"><div class="stat-label">Hashtags</div><div class="stat-value" id="stat-hashtags">0</div></div>
        <div class="stat-card orange"><div class="stat-label">Avg Engagement</div><div class="stat-value" id="stat-engagement">0</div></div>
        <div class="stat-card gray"><div class="stat-label">Network Nodes</div><div class="stat-value" id="stat-nodes">0</div></div>
        <div class="stat-card pink"><div class="stat-label">Network Edges</div><div class="stat-value" id="stat-edges">0</div></div>
        <div class="stat-card yellow"><div class="stat-label">Density</div><div class="stat-value" id="stat-density">0</div></div>
        <div class="stat-card cyan"><div class="stat-label">Communities</div><div class="stat-value" id="stat-communities">0</div></div>
        <div class="stat-card red"><div class="stat-label">Suspicious Accounts</div><div class="stat-value" id="stat-suspicious">0</div></div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Sidebar -->
      <div class="sidebar">
        <!-- Education panel -->
        <div class="info-panel" id="edu-panel" style="margin-bottom:1.5rem;">
          <div class="info-title" style="margin-bottom:.5rem;">Some useful info:</div>
          <div id="edu-basics" class="small">
            <p><b>Nodes</b> are users or hashtags; <b>edges</b> connect them (mentions, co-hashtags, etc.).</p>
            <p><b>Degree</b> = how many neighbors a node has. Hubs can shape attention; high-degree hashtags often mark narratives.</p>
            <p><b>Clustering</b> ≈ how connected a node's neighbors are. High clustering hints at tight echo chambers.</p>
            <p><b>Communities</b> are groups more connected inside than outside — useful to find sub-audiences or coordinated clusters.</p>
          </div>
          <div class="section-divider" style="margin:.75rem 0;"></div>
          <div id="edu-coach" class="small">
            <p><b>How to:</b> load data, pick a network type, then <i>hover</i> nodes for quick stats or <i>click</i> for deep-dive & example posts.</p>
          </div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6"></path>
              <path d="M17 12h6M1 12h6"></path>
            </svg>
            Network Type
          </label>
          <select id="network-type">
            <option value="mention">User Mentions Network</option>
            <option value="coHashtag">Hashtag Co-occurrence</option>
            <option value="userHashtag">User-Hashtag Network</option>
            <option value="hashtag">Hashtag Usage</option>
            <option value="photoTag" title="Instagram only: users tagged in photos">📷 Photo Tag Network (Instagram)</option>
            <option value="location" title="Instagram only: posts by location">📍 Location Network (Instagram)</option>
          </select>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="6"></circle>
              <circle cx="12" cy="12" r="2"></circle>
            </svg>
            Node Size By
          </label>
          <select id="node-size-by">
            <option value="degree">Degree (connections)</option>
            <option value="followers">Followers/Usage Count</option>
            <option value="uniform">Uniform Size</option>
          </select>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            Time Range Filter
          </label>
          <div class="date-range">
            <div class="date-input-wrapper">
              <label class="date-label">From</label>
              <input type="date" id="date-start">
            </div>
            <div class="date-input-wrapper">
              <label class="date-label">To</label>
              <input type="date" id="date-end">
            </div>
          </div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
            Minimum Engagement
          </label>
          <input type="range" id="engagement-filter" min="0" max="10000" step="100" value="0">
          <div class="range-value" id="engagement-value">0+ interactions</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            CIB Detection Sensitivity
          </label>
          <input type="range" id="cib-threshold" min="1" max="10" step="1" value="5">
          <div class="range-value" id="threshold-value">Medium (5)</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            Synchronized Posting Time Window
          </label>
          <input type="range" id="time-window" min="60" max="1800" step="60" value="300">
          <div class="range-value" id="time-window-value">5 minutes</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            Search
          </label>
          <input type="text" id="search-input" placeholder="Search nodes...">
        </div>

        <div class="control-group">
          <button class="btn btn-cib" id="cib-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            Detect Coordinated Behavior
          </button>
          <button class="btn btn-detect" id="detect-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6"></path>
              <path d="M17 12h6M1 12h6"></path>
            </svg>
            Detect Communities
          </button>
          <button class="btn btn-export" id="export-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Export Network Data
          </button>
        </div>

        <div class="section-divider"></div>

        <!-- CIB Detection Results -->
        <div class="info-panel" id="cib-panel" style="display: none;">
          <div class="info-title" style="margin-bottom: 0.75rem;">CIB Detection Results</div>
          <div id="cib-results"></div>
          <div class="warning-box">
            <p><strong>Note:</strong> These are indicators, not proof. Legitimate activism and organic coordination may trigger signals. Always verify with manual inspection.</p>
          </div>
        </div>

        <!-- Network Metrics -->
        <div class="info-panel" id="metrics-panel" style="display: none;">
          <div class="info-title" style="margin-bottom: 0.75rem;">Network Metrics</div>
          <ul class="metrics-list" id="metrics-list"></ul>
        </div>

        <!-- Selected Node Info (sidebar) -->
        <div class="info-panel" id="node-info" style="display: none; margin-top: 1rem;">
          <div class="info-header">
            <div class="info-title">Node Details</div>
            <button class="close-btn" id="close-info">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
          <div id="node-details"></div>
        </div>

        <!-- Legend -->
        <div class="legend" style="margin-top: 1rem;">
          <div class="legend-title">Legend</div>
          <div class="legend-item"><div class="legend-dot" style="background:#dc2626;"></div><span>Suspicious/CIB Account</span></div>
          <div class="legend-item"><div class="legend-dot blue" style="background:#3b82f6;"></div><span>Verified User</span></div>
          <div class="legend-item"><div class="legend-dot purple" style="background:#8b5cf6;"></div><span>Regular User</span></div>
          <div class="legend-item"><div class="legend-dot green" style="background:#10b981;"></div><span>Hashtag</span></div>
          <div class="legend-item"><div class="legend-dot" style="background:#f59e0b;"></div><span>Location (Instagram)</span></div>
          <div class="legend-note">Red nodes indicate accounts flagged as potentially coordinated based on behavioral indicators.</div>
        </div>

      </div>

      <!-- Canvas area -->
      <div class="canvas-container">
        <canvas id="network-canvas"></canvas>

        <!-- Hover tooltip (simple) -->
        <div id="node-tooltip" style="
          position:absolute; pointer-events:none; display:none;
          background:#111827; color:#fff; padding:.4rem .6rem; border-radius:.375rem;
          font-size:12px; box-shadow:0 6px 20px rgba(0,0,0,.2); z-index:2;">
        </div>

        <!-- Click modal (rich) -->
        <div id="node-modal" style="
          position:fixed; inset:0; background:rgba(0,0,0,.5); display:none;
          align-items:center; justify-content:center; z-index:2000;">
          <div style="width:min(780px,92vw); max-height:80vh; overflow:auto; background:#fff; border-radius:12px;
                      box-shadow:0 20px 60px rgba(0,0,0,.35);">
            <div style="padding:16px 18px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between;">
              <div id="modal-title" style="font-weight:700; font-size:16px;">Node</div>
              <button id="modal-close" style="border:none; background:#f3f4f6; padding:.4rem .6rem; border-radius:8px; cursor:pointer;">Close</button>
            </div>
            <div id="modal-body" style="padding:16px 18px; font-size:14px;"></div>
          </div>
        </div>

        <div class="empty-state" id="empty-state">
          <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <div class="empty-title">No Data Loaded</div>
          <div class="empty-text">Upload a Zeeschuimer NDJSON file to get started</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Processing...</div>
  </div>

  <script>
    // =========================
    // Global state
    // =========================
    let rawData = [];
    let filteredData = [];
    let graphData = null;
    let nodes = [];
    let communities = null;
    let cibDetection = null;
    let animationFrame = null;
    let networkMetrics = null;

    // Expose nodes globally for WebGL renderer access
    window.nodes = nodes;

    // Hover & modal helpers / indexes
    let idToNode = new Map();     // node.id -> node (with x,y)
    let adjacency = new Map();    // node.id -> Set(neighborIds)
    let hoveredNode = null;

    // =========================
    // Platform Detection & Normalization
    // =========================
    function detectPlatform(post) {
      const platform = post.source_platform || '';
      if (platform.includes('instagram')) return 'instagram';
      if (platform.includes('tiktok')) return 'tiktok';
      return 'unknown';
    }

    // Extract hashtags from text (for Instagram)
    function extractHashtagsFromText(text) {
      if (!text) return [];
      const matches = text.match(/#(\w+)/g) || [];
      return matches.map((tag, idx) => ({
        id: `ig_${tag.substring(1)}_${idx}`, // unique ID for each hashtag
        title: tag.substring(1) // remove the #
      }));
    }

    // Extract mentions from text (for Instagram)
    function extractMentionsFromText(text) {
      if (!text) return [];
      const matches = text.match(/@(\w+)/g) || [];
      return matches.map(mention => ({
        username: mention.substring(1) // remove the @
      }));
    }

    // Normalize post data across platforms
    function normalizePost(post) {
      const platform = detectPlatform(post);
      const normalized = { ...post, platform };

      if (platform === 'instagram') {
        // Normalize Instagram data to TikTok-like structure
        const ig = post.data;
        const owner = ig.owner || ig.user || {};
        const caption = ig.caption?.text || '';
        
        normalized.data = {
          ...ig,
          // Author info
          author: {
            id: owner.pk || owner.id,
            uniqueId: owner.username,
            nickname: owner.full_name || owner.username,
            verified: owner.is_verified || false
          },
          // Timestamp
          createTime: ig.taken_at,
          // Caption
          desc: caption,
          // Extract hashtags from caption
          challenges: extractHashtagsFromText(caption),
          // Extract mentions from caption
          textExtra: extractMentionsFromText(caption).map(m => ({
            type: 0,
            userUniqueId: m.username,
            userId: null // Instagram doesn't provide user IDs in mentions
          })),
          // Engagement stats
          stats: {
            diggCount: ig.like_count || 0,
            commentCount: ig.comment_count || 0,
            shareCount: 0, // Instagram doesn't expose share count
            playCount: ig.view_count || 0
          },
          // Author stats (not available in Instagram post data)
          authorStats: {
            followerCount: 0
          },
          // Keep Instagram-specific fields
          _instagram: {
            location: ig.location,
            usertags: ig.usertags,
            carousel_media: ig.carousel_media
          }
        };
      } else if (platform === 'tiktok') {
        // TikTok data is already in the right format, just mark platform
        normalized.data = { ...post.data };
      }

      return normalized;
    }

    // Normalize all raw data on load
    function normalizeRawData(data) {
      return data.map(post => normalizePost(post));
    }

    // =========================
    // DOM elements
    // =========================
    const fileInput = document.getElementById('file-input');
    const networkTypeSelect = document.getElementById('network-type');
    const nodeSizeBySelect = document.getElementById('node-size-by');
    const engagementFilter = document.getElementById('engagement-filter');
    const engagementValue = document.getElementById('engagement-value');
    const cibThreshold = document.getElementById('cib-threshold');
    const thresholdValue = document.getElementById('threshold-value');
    const timeWindowInput = document.getElementById('time-window');
    const timeWindowValue = document.getElementById('time-window-value');
    const dateStart = document.getElementById('date-start');
    const dateEnd = document.getElementById('date-end');
    const searchInput = document.getElementById('search-input');
    const exportBtn = document.getElementById('export-btn');
    const detectBtn = document.getElementById('detect-btn');
    const cibBtn = document.getElementById('cib-btn');
    const canvas = document.getElementById('network-canvas');
    let ctx = null; // Don't create context yet - let renderer decide
    let gl = null;
    let gpuRenderer = null;
    const emptyState = document.getElementById('empty-state');
    const statsDiv = document.getElementById('stats');
    const nodeInfo = document.getElementById('node-info');
    const nodeDetails = document.getElementById('node-details');
    const closeInfo = document.getElementById('close-info');
    const loading = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const metricsPanel = document.getElementById('metrics-panel');
    const metricsList = document.getElementById('metrics-list');
    const cibPanel = document.getElementById('cib-panel');
    const cibResults = document.getElementById('cib-results');
    const tooltipEl = document.getElementById('node-tooltip');
    const modalEl   = document.getElementById('node-modal');
    const modalClose= document.getElementById('modal-close');
    const modalTitle= document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');
    const platformIndicator = document.getElementById('platform-indicator');
    const renderingIndicator = document.getElementById('rendering-indicator');

    // =========================
    // UI constants
    // =========================
    const communityColors = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#ec4899','#14b8a6','#f97316','#06b6d4','#84cc16'];
    const thresholdLabels = {
      1:'Very Low (1)',2:'Low (2)',3:'Low-Med (3)',4:'Medium-Low (4)',5:'Medium (5)',
      6:'Medium-High (6)',7:'High-Med (7)',8:'High (8)',9:'Very High (9)',10:'Maximum (10)'
    };

    cibThreshold.addEventListener('input', (e)=>{ thresholdValue.textContent = thresholdLabels[e.target.value]; });

    timeWindowInput.addEventListener('input', (e) => {
      const minutes = Math.floor(e.target.value / 60);
      timeWindowValue.textContent = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
    });

    // =========================
    // File upload
    // =========================
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      loading.classList.add('active');
      loadingText.textContent = 'Loading data...';

      try {
        const text = await file.text();
        const lines = text.trim().split('\n');
        const parsed = lines.map(line => JSON.parse(line));
        
        // Normalize data to handle both TikTok and Instagram
        rawData = normalizeRawData(parsed);

        // Detect platforms
        const platformCounts = {};
        rawData.forEach(p => {
          const platform = p.platform || 'unknown';
          platformCounts[platform] = (platformCounts[platform] || 0) + 1;
        });
        
        const platformParts = [];
        if (platformCounts.tiktok) platformParts.push(`🎵 TikTok (${platformCounts.tiktok})`);
        if (platformCounts.instagram) platformParts.push(`📷 Instagram (${platformCounts.instagram})`);
        if (platformCounts.unknown) platformParts.push(`❓ Unknown (${platformCounts.unknown})`);
        
        const platformText = platformParts.join(' · ') || 'No data';
        platformIndicator.textContent = `· ${platformText}`;
        console.log(`Loaded ${rawData.length} posts from: ${platformText}`);

        // set date bounds from data (both platforms use createTime after normalization)
        const dates = rawData.map(p => p.data?.createTime).filter(Boolean);
        if (dates.length > 0) {
          const minDate = new Date(Math.min(...dates) * 1000);
          const maxDate = new Date(Math.max(...dates) * 1000);
          dateStart.value = minDate.toISOString().split('T')[0];
          dateEnd.value = maxDate.toISOString().split('T')[0];
        }

        calculateStats();
        updateNetwork();
        emptyState.style.display = 'none';
        statsDiv.style.display = 'grid';
        exportBtn.disabled = false;
        detectBtn.disabled = false;
        cibBtn.disabled = false;
      } catch (err) {
        alert('Error parsing file: ' + err.message);
      } finally {
        loading.classList.remove('active');
      }
    });

    // =========================
    // Stats
    // =========================
    function calculateStats() {
      const uniqueUsers = new Set(rawData.map(p => p.data?.author?.id).filter(Boolean));
      const allHashtags = rawData.flatMap(p => p.data?.challenges?.map(c => c.title) || []);
      const uniqueHashtags = new Set(allHashtags);

      const totalEngagement = rawData.reduce((sum, p) => {
        return sum + (p.data?.stats?.diggCount || 0) + (p.data?.stats?.commentCount || 0);
      }, 0);

      document.getElementById('stat-posts').textContent = rawData.length;
      document.getElementById('stat-users').textContent = uniqueUsers.size;
      document.getElementById('stat-hashtags').textContent = uniqueHashtags.size;
      document.getElementById('stat-engagement').textContent = rawData.length ? Math.round(totalEngagement / rawData.length) : 0;
    }

    // =========================
    // Filters (engagement + date)
    // =========================
    function filterData() {
      const minEngagement = parseInt(engagementFilter.value, 10);
      const startDate = dateStart.value ? new Date(dateStart.value).getTime() / 1000 : 0;
      const endDate = dateEnd.value ? new Date(dateEnd.value).getTime() / 1000 : Infinity;

      filteredData = rawData.filter(post => {
        const engagement = (post.data?.stats?.diggCount || 0) + (post.data?.stats?.commentCount || 0) + (post.data?.stats?.shareCount || 0);
        const postTime = post.data?.createTime || 0;
        return engagement >= minEngagement && postTime >= startDate && postTime <= endDate;
      });

      return filteredData;
    }

    // =========================
    // CIB detection (heuristics)
    // =========================
    function detectCIB() {
      loading.classList.add('active');
      loadingText.textContent = 'Analyzing coordinated behavior patterns...';

      setTimeout(() => {
        const threshold = parseInt(cibThreshold.value, 10);
        const sensitivity = 11 - threshold; // higher threshold = stricter

        const results = { suspiciousUsers: new Set(), indicators: {} };

        // 1) Synchronized posting
        const postsByUser = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const timestamp = post.data?.createTime;
          if (!userId || !timestamp) return;
          if (!postsByUser.has(userId)) postsByUser.set(userId, []);
          postsByUser.get(userId).push({ timestamp, post });
        });
        const timeWindow = parseInt(timeWindowInput.value, 10);
        const synchGroups = [];
        const userTs = Array.from(postsByUser.entries());
        for (let i=0;i<userTs.length;i++){
          for (let j=i+1;j<userTs.length;j++){
            const [u1, p1] = userTs[i]; const [u2, p2] = userTs[j];
            let syncCount = 0;
            p1.forEach(a => p2.forEach(b => { if (Math.abs(a.timestamp - b.timestamp) < timeWindow) syncCount++; }));
            if (syncCount >= Math.max(2, Math.floor(10/sensitivity))) {
              results.suspiciousUsers.add(u1); results.suspiciousUsers.add(u2); synchGroups.push({ u1, u2, syncCount });
            }
          }
        }
        results.indicators.synchronized = synchGroups.length;

        // 2) Identical hashtag sequences
        const hashtagSequences = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const hashtags = post.data?.challenges?.map(c => c.title).join(',') || '';
          if (!userId || !hashtags) return;
          const key = hashtags;
          if (!hashtagSequences.has(key)) hashtagSequences.set(key, new Set());
          hashtagSequences.get(key).add(userId);
        });
        let identicalHashtagUsers = 0;
        hashtagSequences.forEach(users => {
          if (users.size >= Math.max(3, Math.floor(15/sensitivity))) {
            users.forEach(u => results.suspiciousUsers.add(u));
            identicalHashtagUsers += users.size;
          }
        });
        results.indicators.identicalHashtags = identicalHashtagUsers;

        // 3) Similar username prefixes
        const usernames = new Map();
        filteredData.forEach(post => {
          const author = post.data?.author; if (!author) return;
          const username = author.uniqueId || author.nickname || '';
          const userId = author.id;
          const prefix = username.substring(0, Math.min(7, username.length));
          if (prefix.length < 4) return;
          if (!usernames.has(prefix)) usernames.set(prefix, new Set());
          usernames.get(prefix).add(userId);
        });
        let similarUsernameCount = 0;
        usernames.forEach(users => {
          if (users.size >= Math.max(3, Math.floor(12/sensitivity))) {
            users.forEach(u => results.suspiciousUsers.add(u));
            similarUsernameCount += users.size;
          }
        });
        results.indicators.similarUsernames = similarUsernameCount;

        // 4) High-volume posting
        const minPosts = Math.max(5, Math.floor(25/sensitivity));
        results.indicators.highVolume = 0;
        postsByUser.forEach((posts, userId) => {
          if (posts.length >= minPosts) {
            const ts = posts.map(p => p.timestamp).sort();
            const span = ts[ts.length-1] - ts[0];
            const postsPerDay = span>0 ? (posts.length / (span / 86400)) : posts.length;
            if (postsPerDay > Math.max(10, 50/sensitivity)) results.suspiciousUsers.add(userId);
            results.indicators.highVolume++;
          }
        });

        // 5) Duplicate captions
        const captions = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const caption = post.data?.desc || '';
          if (!userId || caption.length < 10) return;
          const normalized = caption.toLowerCase().replace(/[^\w\s]/g,'').trim();
          if (!captions.has(normalized)) captions.set(normalized, new Set());
          captions.get(normalized).add(userId);
        });
        let duplicateCaptionUsers = 0;
        captions.forEach(users => {
          if (users.size >= Math.max(2, Math.floor(8/sensitivity))) {
            users.forEach(u => results.suspiciousUsers.add(u));
            duplicateCaptionUsers += users.size;
          }
        });
        results.indicators.duplicateCaptions = duplicateCaptionUsers;

        // Build userId -> username lookup
        const userIdToName = new Map();
        filteredData.forEach(post => {
          const author = post.data?.author;
          if (author?.id) {
            userIdToName.set(author.id, author.uniqueId || author.nickname || `user_${author.id}`);
          }
        });
        
        // risk scores and reasons
        results.userScores = new Map();
        results.userReasons = new Map();
        results.suspiciousUsers.forEach(userId => {
          let score = 0;
          let reasons = [];
          
          // Check synchronized posting
          const userSyncGroups = synchGroups.filter(g => g.u1===userId || g.u2===userId);
          if (userSyncGroups.length > 0) {
            score += 25;
            const partners = userSyncGroups.map(g => {
              const partnerId = g.u1 === userId ? g.u2 : g.u1;
              return userIdToName.get(partnerId) || partnerId;
            }).slice(0, 5);
            const more = userSyncGroups.length > 5 ? ` and ${userSyncGroups.length - 5} more` : '';
            reasons.push(`Synchronized posting with: ${partners.join(', ')}${more}`);
          }
          
          // Check identical hashtag sequences (with other users)
          const userPosts = filteredData.filter(p => p.data?.author?.id === userId);
          const hashtagPartners = [];
          hashtagSequences.forEach((users, seq) => {
            if (users.has(userId) && users.size >= Math.max(3, Math.floor(15/sensitivity))) {
              const others = Array.from(users).filter(u => u !== userId).map(u => userIdToName.get(u) || u);
              hashtagPartners.push(...others);
            }
          });
          if (hashtagPartners.length > 0) {
            score += 20;
            const display = hashtagPartners.slice(0, 5);
            const more = hashtagPartners.length > 5 ? ` and ${hashtagPartners.length - 5} more` : '';
            reasons.push(`Identical hashtag sequences with: ${display.join(', ')}${more}`);
          }
          
          // Check high-volume posting
          if (userPosts.length >= minPosts) {
            const ts = userPosts.map(p => p.data?.createTime).filter(Boolean).sort();
            if (ts.length > 1) {
              const span = ts[ts.length-1] - ts[0];
              const postsPerDay = span>0 ? (userPosts.length / (span / 86400)) : userPosts.length;
              if (postsPerDay > Math.max(10, 50/sensitivity)) {
                score += 15;
                reasons.push(`High-volume posting (${postsPerDay.toFixed(1)} posts/day)`);
              }
            }
          }
          
          // Check duplicate captions (with other users)
          const captionPartners = [];
          captions.forEach((users, caption) => {
            if (users.has(userId) && users.size >= Math.max(2, Math.floor(8/sensitivity))) {
              const others = Array.from(users).filter(u => u !== userId).map(u => userIdToName.get(u) || u);
              captionPartners.push(...others);
            }
          });
          if (captionPartners.length > 0) {
            score += 20;
            const display = captionPartners.slice(0, 5);
            const more = captionPartners.length > 5 ? ` and ${captionPartners.length - 5} more` : '';
            reasons.push(`Duplicate captions with: ${display.join(', ')}${more}`);
          }
          
          // Check similar username pattern
          const author = userPosts[0]?.data?.author;
          if (author) {
            const username = author.uniqueId || author.nickname || '';
            const prefix = username.substring(0, Math.min(7, username.length));
            if (prefix.length >= 4 && usernames.has(prefix) && usernames.get(prefix).size >= Math.max(3, Math.floor(12/sensitivity))) {
              score += 10;
              const similarUsers = Array.from(usernames.get(prefix)).filter(u => u !== userId).map(u => userIdToName.get(u) || u);
              const display = similarUsers.slice(0, 5);
              const more = similarUsers.length > 5 ? ` and ${similarUsers.length - 5} more` : '';
              reasons.push(`Similar username pattern with: ${display.join(', ')}${more}`);
            }
          }
          
          results.userScores.set(userId, score);
          results.userReasons.set(userId, reasons);
        });

        cibDetection = results;
        displayCIBResults(results);

        // mark nodes
        if (nodes.length > 0) {
          nodes.forEach(node => {
            const plainId = node.id.replace(/^u_/,'');
            if (results.suspiciousUsers.has(node.id) || results.suspiciousUsers.has(plainId)) {
              node.suspicious = true;
              node.cibScore = results.userScores.get(node.id) || results.userScores.get(plainId) || 0;
              node.cibReasons = results.userReasons.get(node.id) || results.userReasons.get(plainId) || [];
            }
          });
          drawNetwork();
        }
        document.getElementById('stat-suspicious').textContent = results.suspiciousUsers.size;

        loading.classList.remove('active');
        updateCoach();
      }, 100);
    }

    function displayCIBResults(results) {
      let html = '<ul class="metrics-list">';
      html += `<li><span class="metric-name">Suspicious Accounts</span><span class="metric-value cib-score">${results.suspiciousUsers.size}</span></li>`;
      html += `<li><span class="metric-name">Synchronized Posting</span><span class="metric-value">${results.indicators.synchronized} pairs</span></li>`;
      html += `<li><span class="metric-name">Identical Hashtags</span><span class="metric-value">${results.indicators.identicalHashtags} users</span></li>`;
      html += `<li><span class="metric-name">Similar Usernames</span><span class="metric-value">${results.indicators.similarUsernames} users</span></li>`;
      html += `<li><span class="metric-name">High Volume Posting</span><span class="metric-value">${results.indicators.highVolume} users</span></li>`;
      html += `<li><span class="metric-name">Duplicate Captions</span><span class="metric-value">${results.indicators.duplicateCaptions} users</span></li>`;
      html += '</ul>';
      cibResults.innerHTML = html;
      cibPanel.style.display = 'block';
    }

    // =========================
    // Network extraction
    // =========================
    function extractMentionNetwork(posts) {
      const nodeMap = new Map();
      const links = [];

      posts.forEach(post => {
        const author = post.data?.author;
        if (!author) return;

        const authorId = author.id;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            verified: author.verified,
            followers: post.data?.authorStats?.followerCount || 0,
            type: 'user'
          });
        }
        const mentions = post.data?.textExtra?.filter(t => t.type === 0) || [];
        mentions.forEach(mention => {
          if (!nodeMap.has(mention.userId)) {
            nodeMap.set(mention.userId, {
              id: mention.userId,
              label: mention.userUniqueId || String(mention.userId),
              type: 'user', followers: 0
            });
          }
          links.push({ source: authorId, target: mention.userId, postId: post.item_id });
        });
      });

      return { nodes: Array.from(nodeMap.values()), links };
    }

    function extractCoHashtagNetwork(posts) {
      const nodeMap = new Map();
      const linkMap = new Map();

      posts.forEach(post => {
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          const tagId = tag.id;
          if (!nodeMap.has(tagId)) nodeMap.set(tagId, { id: tagId, label: tag.title, count: 0, type: 'hashtag' });
          nodeMap.get(tagId).count++;
        });
        for (let i=0;i<hashtags.length;i++){
          for (let j=i+1;j<hashtags.length;j++){
            const source = hashtags[i].id, target = hashtags[j].id;
            const key = [source, target].sort().join('-');
            if (!linkMap.has(key)) linkMap.set(key, { source, target, weight: 0 });
            linkMap.get(key).weight++;
          }
        }
      });
      return { nodes: Array.from(nodeMap.values()), links: Array.from(linkMap.values()) };
    }

    function extractUserHashtagNetwork(posts) {
      const nodeMap = new Map();
      const links = [];

      posts.forEach(post => {
        const author = post.data?.author;
        if (!author) return;

        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId, label: author.uniqueId || author.nickname, type: 'user',
            verified: author.verified, followers: post.data?.authorStats?.followerCount || 0
          });
        }
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          const tagId = `h_${tag.id}`;
          if (!nodeMap.has(tagId)) nodeMap.set(tagId, { id: tagId, label: tag.title, type: 'hashtag', count: 0 });
          nodeMap.get(tagId).count++;
          links.push({ source: authorId, target: tagId, postId: post.item_id });
        });
      });

      return { nodes: Array.from(nodeMap.values()), links };
    }

    function extractHashtagNetwork(posts) {
      const nodeMap = new Map();
      posts.forEach(post => {
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          if (!nodeMap.has(tag.id)) nodeMap.set(tag.id, { id: tag.id, label: tag.title, count: 0, totalEngagement: 0, type: 'hashtag' });
          const node = nodeMap.get(tag.id);
          node.count++;
          node.totalEngagement += (post.data?.stats?.diggCount || 0);
        });
      });
      return { nodes: Array.from(nodeMap.values()), links: [] };
    }

    // Instagram-specific: Photo tag network
    function extractPhotoTagNetwork(posts) {
      const nodeMap = new Map();
      const links = [];
      
      posts.forEach(post => {
        if (post.platform !== 'instagram') return; // Only Instagram has photo tags
        
        const author = post.data?.author;
        const usertags = post.data?._instagram?.usertags?.in || [];
        
        if (!author || usertags.length === 0) return;
        
        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            type: 'user',
            verified: author.verified,
            followers: 0
          });
        }
        
        // Create connections to tagged users
        usertags.forEach(tag => {
          const taggedUser = tag.user;
          if (!taggedUser) return;
          
          const taggedId = `u_${taggedUser.id}`;
          if (!nodeMap.has(taggedId)) {
            nodeMap.set(taggedId, {
              id: taggedId,
              label: taggedUser.username,
              type: 'user',
              verified: taggedUser.is_verified || false,
              followers: 0
            });
          }
          
          links.push({ source: authorId, target: taggedId, postId: post.item_id });
        });
      });
      
      return { nodes: Array.from(nodeMap.values()), links };
    }

    // Instagram-specific: Location network
    function extractLocationNetwork(posts) {
      const nodeMap = new Map();
      const links = [];
      
      posts.forEach(post => {
        if (post.platform !== 'instagram') return; // Only Instagram has location data
        
        const author = post.data?.author;
        const location = post.data?._instagram?.location;
        
        if (!author || !location) return;
        
        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            type: 'user',
            verified: author.verified,
            followers: 0
          });
        }
        
        const locationId = `loc_${location.pk}`;
        if (!nodeMap.has(locationId)) {
          nodeMap.set(locationId, {
            id: locationId,
            label: location.name,
            type: 'location',
            count: 0,
            lat: location.lat,
            lng: location.lng
          });
        }
        
        nodeMap.get(locationId).count++;
        links.push({ source: authorId, target: locationId, postId: post.item_id });
      });
      
      return { nodes: Array.from(nodeMap.values()), links };
    }

    // =========================
    // Metrics & communities
    // =========================
    function calculateNetworkMetrics(graph) {
      const n = graph.nodes.length;
      const m = graph.links.length;
      if (n === 0) return null;

      const maxEdges = (n * (n - 1)) / 2;
      const density = maxEdges > 0 ? (m / maxEdges).toFixed(3) : 0;

      const degrees = new Map();
      graph.nodes.forEach(node => degrees.set(node.id, 0));
      graph.links.forEach(link => {
        degrees.set(link.source, (degrees.get(link.source) || 0) + 1);
        degrees.set(link.target, (degrees.get(link.target) || 0) + 1);
      });

      const avgDegree = (Array.from(degrees.values()).reduce((a,b)=>a+b,0) / n).toFixed(2);
      const maxDegree = degrees.size ? Math.max(...Array.from(degrees.values())) : 0;

      graph.nodes.forEach(node => { node.degree = degrees.get(node.id) || 0; });

      let totalClustering = 0, validNodes = 0;
      graph.nodes.forEach(node => {
        const neighbors = new Set();
        graph.links.forEach(link => {
          if (link.source === node.id) neighbors.add(link.target);
          if (link.target === node.id) neighbors.add(link.source);
        });
        const k = neighbors.size;
        if (k < 2) return;
        let triangles = 0;
        const arr = Array.from(neighbors);
        for (let i=0;i<arr.length;i++){
          for (let j=i+1;j<arr.length;j++){
            if (graph.links.some(l => (l.source===arr[i] && l.target===arr[j]) || (l.target===arr[i] && l.source===arr[j]))) triangles++;
          }
        }
        const possible = (k*(k-1))/2;
        if (possible > 0) { totalClustering += triangles/possible; validNodes++; }
      });
      const avgClustering = validNodes > 0 ? (totalClustering / validNodes).toFixed(3) : 0;

      return { nodes: n, edges: m, density, avgDegree, maxDegree, avgClustering };
    }

    function displayMetrics(metrics) {
      if (!metrics) { metricsPanel.style.display = 'none'; return; }
      metricsList.innerHTML = `
        <li><span class="metric-name">Nodes</span><span class="metric-value">${metrics.nodes}</span></li>
        <li><span class="metric-name">Edges</span><span class="metric-value">${metrics.edges}</span></li>
        <li><span class="metric-name">Density</span><span class="metric-value">${metrics.density}</span></li>
        <li><span class="metric-name">Avg Degree</span><span class="metric-value">${metrics.avgDegree}</span></li>
        <li><span class="metric-name">Max Degree</span><span class="metric-value">${metrics.maxDegree}</span></li>
        <li><span class="metric-name">Clustering</span><span class="metric-value">${metrics.avgClustering}</span></li>
      `;
      metricsPanel.style.display = 'block';
    }

    function detectCommunities(graph) {
      if (graph.nodes.length === 0 || graph.links.length === 0) return null;

      const adj = new Map();
      graph.nodes.forEach(n => adj.set(n.id, new Set()));
      graph.links.forEach(l => { adj.get(l.source).add(l.target); adj.get(l.target).add(l.source); });

      const labels = new Map();
      graph.nodes.forEach((n,i)=>labels.set(n.id, i));

      let changed = true, iterations = 0;
      const maxIterations = 100;

      while (changed && iterations < maxIterations) {
        changed = false; iterations++;
        const shuffled = [...graph.nodes].sort(() => Math.random()-0.5);
        shuffled.forEach(node => {
          const neighbors = adj.get(node.id); if (neighbors.size===0) return;
          const counts = new Map();
          neighbors.forEach(nb => { const lab = labels.get(nb); counts.set(lab, (counts.get(lab)||0)+1); });
          let best = labels.get(node.id), bestCount = 0;
          counts.forEach((c,lab)=>{ if (c>bestCount){ bestCount=c; best=lab; } });
          if (best !== labels.get(node.id)) { labels.set(node.id, best); changed = true; }
        });
      }
      const uniq = [...new Set(labels.values())];
      const remap = new Map(); uniq.forEach((lab,i)=>remap.set(lab,i));
      const out = new Map(); labels.forEach((lab,id)=>out.set(id, remap.get(lab)));
      return { communities: out, count: uniq.length };
    }

    // =========================
    // Update network
    // =========================
    function updateNetwork() {
      loading.classList.add('active');
      loadingText.textContent = 'Building network...';

      setTimeout(() => {
        const filtered = filterData();
        const networkType = networkTypeSelect.value;

        let network;
        switch (networkType) {
          case 'mention':     network = extractMentionNetwork(filtered);     break;
          case 'coHashtag':   network = extractCoHashtagNetwork(filtered);   break;
          case 'userHashtag': network = extractUserHashtagNetwork(filtered); break;
          case 'hashtag':     network = extractHashtagNetwork(filtered);     break;
          case 'photoTag':    network = extractPhotoTagNetwork(filtered);    break;
          case 'location':    network = extractLocationNetwork(filtered);    break;
          default:            network = { nodes: [], links: [] };
        }

        graphData = network;
        communities = null;
        cibDetection = null;

        networkMetrics = calculateNetworkMetrics(network);
        displayMetrics(networkMetrics);

        document.getElementById('stat-nodes').textContent = network.nodes.length;
        document.getElementById('stat-edges').textContent = network.links.length;
        document.getElementById('stat-density').textContent = networkMetrics ? networkMetrics.density : '0';
        document.getElementById('stat-communities').textContent = '0';
        document.getElementById('stat-suspicious').textContent = '0';

        cibPanel.style.display = 'none';

        // Build adjacency (for degree/hover-neighbor glow) and an id->node map
        buildAdjacency(graphData);
        idToNode = new Map(graphData.nodes.map(n => [n.id, n]));

        initializeVisualization();
        loading.classList.remove('active');
        updateCoach();
      }, 100);
    }

    // =========================
    // GPU Renderer (WebGL)
    // =========================
    class GPUNetworkRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.gl = null;
        this.edgeProgram = null;
        this.nodeProgram = null;
        this.edgeBuffers = null;
        this.nodeBuffers = null;
        this.textRenderer = null;
        this.initialized = false;
        
        this.initWebGL();
      }

      initWebGL() {
        console.log('=== WebGL Context Creation Diagnostics ===');
        console.log('Canvas element:', this.canvas);
        console.log('Canvas dimensions:', {
          width: this.canvas.width,
          height: this.canvas.height,
          offsetWidth: this.canvas.offsetWidth,
          offsetHeight: this.canvas.offsetHeight
        });
        
        try {
          // ✅ CRITICAL CHECK: Does canvas already have a NON-WebGL context?
          // IMPORTANT: Do NOT call getContext('2d') here — that would CREATE a 2D context.
          if (this.canvas.__ctxType && this.canvas.__ctxType !== 'webgl' && this.canvas.__ctxType !== 'webgl2') {
            console.error('❌ FATAL ERROR: Canvas already initialized with a non-WebGL context (' + this.canvas.__ctxType + ')');
            console.error('❌ Cannot create WebGL context on a canvas with an existing non-WebGL context');
            return false;
          }
          
          // CRITICAL FIX: Store and completely reset canvas state
          const computedStyle = window.getComputedStyle(this.canvas);
          const originalDisplay = computedStyle.display;
          const originalPosition = computedStyle.position;
          const originalVisibility = computedStyle.visibility;
          const originalTransform = computedStyle.transform;
          const originalOpacity = computedStyle.opacity;
          
          // CRITICAL FIX: Ensure canvas has proper dimensions BEFORE context creation
          const rect = this.canvas.getBoundingClientRect();
          if (this.canvas.width === 0 || this.canvas.height === 0) {
            console.log('❌ CRITICAL ISSUE: Canvas has zero dimensions - fixing...');
            this.canvas.width = Math.max(rect.width || this.canvas.offsetWidth || 800, 1);
            this.canvas.height = Math.max(rect.height || this.canvas.offsetHeight || 600, 1);
            console.log('✅ Fixed canvas dimensions:', {
              width: this.canvas.width,
              height: this.canvas.height
            });
          }
          
          // CRITICAL FIX: Temporarily remove any CSS that might interfere with WebGL
          // This is the key fix - CSS transforms and certain positioning can break WebGL
          this.canvas.style.setProperty('transform', 'none', 'important');
          this.canvas.style.setProperty('opacity', '1', 'important');
          this.canvas.style.setProperty('visibility', 'visible', 'important');
          this.canvas.style.setProperty('display', 'block', 'important');
          this.canvas.style.setProperty('position', 'static', 'important');
          this.canvas.style.setProperty('will-change', 'auto', 'important');
          this.canvas.style.setProperty('contain', 'none', 'important');
          
          // Force a reflow to apply the style changes
          this.canvas.offsetHeight;
          
          console.log('🔍 Testing WebGL with cleaned canvas state...');
          
          // CRITICAL FIX: Try WebGL context creation with optimal settings
          const contextAttributes = {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false,
            premultipliedAlpha: false,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: false
          };
          
          // Try WebGL 2 first (better performance), then WebGL 1
          this.gl = this.canvas.getContext('webgl2', contextAttributes) ||
                    this.canvas.getContext('webgl', contextAttributes) ||
                    this.canvas.getContext('experimental-webgl', contextAttributes);
          
          if (!this.gl) {
            console.error('❌ WebGL context creation failed');
            console.error('❌ Possible causes:');
            console.error('   1. Browser extensions blocking WebGL (privacy/ad blockers)');
            console.error('   2. Hardware acceleration disabled in browser settings');
            console.error('   3. GPU blacklisted or unsupported');
            console.error('   4. Canvas already has a different context type');
            console.error('');
            console.error('💡 Try:');
            console.error('   - Open in incognito/private mode');
            console.error('   - Disable browser extensions temporarily');
            console.error('   - Check browser hardware acceleration settings');
            
            // Show user-friendly notification
            this.showWebGLDisabledNotification();
            console.warn('WebGL not supported, falling back to CPU rendering');
            return false;
          }
          
          // Tag the canvas so future checks don't probe/instantiate other contexts
          this.canvas.__ctxType = (this.gl.getParameter(this.gl.VERSION).indexOf('WebGL 2') !== -1) ? 'webgl2' : 'webgl';
          
          console.log('✅ WebGL context created successfully');
          console.log('WebGL context type:', this.gl.constructor.name);
          
          // CRITICAL FIX: Test if context is actually functional
          try {
            const gl = this.gl;
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Test basic drawing setup
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            console.log('✅ WebGL context is functional');
            
            // Log WebGL capabilities
            console.log('WebGL Version:', gl.getParameter(gl.VERSION));
            console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
            console.log('WebGL Renderer:', gl.getParameter(gl.RENDERER));
            
            // Create shaders and buffers
            console.log('Creating WebGL shaders and buffers...');
            const shadersCreated = this.createShaders();
            const buffersCreated = this.createBuffers();
            
            console.log('Shader creation result:', shadersCreated);
            console.log('Buffer creation result:', buffersCreated);
            
            if (shadersCreated && buffersCreated) {
              this.initialized = true;
              console.log('✅ WebGL renderer fully initialized');
              
              // CRITICAL FIX: Don't restore canvas styles that could break WebGL
              // Keep the canvas in the clean state needed for WebGL
              this.canvas.style.setProperty('transform', 'none', 'important');
              this.canvas.style.setProperty('opacity', '1', 'important');
              this.canvas.style.setProperty('visibility', 'visible', 'important');
              this.canvas.style.setProperty('display', 'block', 'important');
              this.canvas.style.setProperty('position', 'static', 'important');
              
              return true;
            } else {
              console.error('❌ Failed to create shaders or buffers');
              return false;
            }
          } catch (glError) {
            console.error('❌ WebGL context is not functional:', glError);
            console.error('❌ Context created but drawing operations fail');
            return false;
          }
        } catch (error) {
          console.error('❌ WebGL initialization threw exception:', error);
          console.error('Error details:', {
            name: error.name,
            message: error.message,
            stack: error.stack
          });
          return false;
        }
      }

      showWebGLDisabledNotification() {
        // Create a user-friendly notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc2626;
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 14px;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 400px;
          line-height: 1.4;
        `;
        notification.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 8px;">⚠️ WebGL Disabled</div>
          <div style="font-size: 12px; margin-bottom: 8px;">Browser extensions or security policies are blocking WebGL.</div>
          <div style="font-size: 11px; opacity: 0.9;">Try disabling extensions or using incognito mode.</div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 8000);
        
        // Click to dismiss
        notification.addEventListener('click', () => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        });
      }

      createShaders() {
        const gl = this.gl;
        
        // Edge shader - draws lines between nodes
        const edgeVertexSource = `
          attribute vec2 a_position;
          attribute vec3 a_color;
          attribute float a_alpha;
          uniform vec2 u_resolution;
          varying vec3 v_color;
          varying float v_alpha;
          
          void main() {
            vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            v_color = a_color;
            v_alpha = a_alpha;
          }
        `;
        
        const edgeFragmentSource = `
          precision mediump float;
          varying vec3 v_color;
          varying float v_alpha;
          
          void main() {
            gl_FragColor = vec4(v_color, v_alpha);
          }
        `;
        
        // Node shader - draws circles for nodes
        const nodeVertexSource = `
          attribute vec2 a_position;
          attribute vec3 a_color;
          attribute float a_radius;
          attribute float a_borderWidth;
          attribute vec3 a_borderColor;
          uniform vec2 u_resolution;
          varying vec3 v_color;
          varying float v_radius;
          varying float v_borderWidth;
          varying vec3 v_borderColor;
          
          void main() {
            vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            v_color = a_color;
            v_radius = a_radius;
            v_borderWidth = a_borderWidth;
            v_borderColor = a_borderColor;
            gl_PointSize = a_radius * 2.0 + a_borderWidth * 2.0;
          }
        `;
        
        const nodeFragmentSource = `
          precision mediump float;
          varying vec3 v_color;
          varying float v_radius;
          varying float v_borderWidth;
          varying vec3 v_borderColor;
          
          void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if (dist > 0.5) {
              discard;
            }
            
            float totalRadius = v_radius + v_borderWidth;
            float normalizedDist = dist * 2.0; // 0 at center, 1 at edge
            
            if (v_borderWidth > 0.0 && normalizedDist > (v_radius / totalRadius)) {
              gl_FragColor = vec4(v_borderColor, 1.0);
            } else {
              gl_FragColor = vec4(v_color, 1.0);
            }
          }
        `;
        
        this.edgeProgram = this.createProgram(edgeVertexSource, edgeFragmentSource);
        this.nodeProgram = this.createProgram(nodeVertexSource, nodeFragmentSource);
        
        // Return true if both programs were created successfully
        return !!(this.edgeProgram && this.nodeProgram);
      }

      createProgram(vertexSource, fragmentSource) {
        const gl = this.gl;
        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(program));
          return null;
        }
        
        return program;
      }

      createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        
        return shader;
      }

      createBuffers() {
        const gl = this.gl;
        
        try {
          // Edge buffers
          this.edgeBuffers = {
            position: gl.createBuffer(),
            color: gl.createBuffer(),
            alpha: gl.createBuffer()
          };
          
          // Node buffers
          this.nodeBuffers = {
            position: gl.createBuffer(),
            color: gl.createBuffer(),
            radius: gl.createBuffer(),
            borderWidth: gl.createBuffer(),
            borderColor: gl.createBuffer()
          };
          
          // Check if all buffers were created successfully
          const edgeBuffersValid = this.edgeBuffers.position && this.edgeBuffers.color && this.edgeBuffers.alpha;
          const nodeBuffersValid = this.nodeBuffers.position && this.nodeBuffers.color && 
                                 this.nodeBuffers.radius && this.nodeBuffers.borderWidth && this.nodeBuffers.borderColor;
          
          return !!(edgeBuffersValid && nodeBuffersValid);
        } catch (error) {
          console.error('Buffer creation failed:', error);
          return false;
        }
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [0.5, 0.5, 0.5];
      }

      render(nodes, edges, width, height) {
        if (!this.initialized) return false;
        
        const gl = this.gl;
        gl.viewport(0, 0, width, height);
        gl.clearColor(1, 1, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        this.renderEdges(edges, width, height);
        this.renderNodes(nodes, width, height);
        
        return true;
      }

      renderEdges(edges, width, height) {
        if (edges.length === 0) return;
        
        const gl = this.gl;
        gl.useProgram(this.edgeProgram);
        
        // Prepare edge data
        const positions = [];
        const colors = [];
        const alphas = [];
        
        edges.forEach(edge => {
          if (!edge.source || !edge.target) return;
          
          const source = window.nodes.find(n => n.id === edge.source);
          const target = window.nodes.find(n => n.id === edge.target);
          if (!source || !target) return;
          
          // Create line segment
          positions.push(source.x, source.y, target.x, target.y);
          
          const weight = edge.weight || 1;
          const alpha = Math.min(0.3 + weight * 0.1, 0.8);
          const color = this.hexToRgb('#d1d5db');
          
          colors.push(...color, ...color);
          alphas.push(alpha, alpha);
        });
        
        if (positions.length === 0) return;
        
        // Set uniforms
        const resolutionLocation = gl.getUniformLocation(this.edgeProgram, 'u_resolution');
        if (resolutionLocation) {
          gl.uniform2f(resolutionLocation, width, height);
        }
        
        // Set attributes
        const positionLocation = gl.getAttribLocation(this.edgeProgram, 'a_position');
        if (positionLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.position);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }
        
        const colorLocation = gl.getAttribLocation(this.edgeProgram, 'a_color');
        if (colorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.color);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(colorLocation);
          gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        const alphaLocation = gl.getAttribLocation(this.edgeProgram, 'a_alpha');
        if (alphaLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.alpha);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(alphaLocation);
          gl.vertexAttribPointer(alphaLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        // Draw edges as lines
        gl.drawArrays(gl.LINES, 0, positions.length / 2);
      }

      renderNodes(nodes, width, height) {
        if (nodes.length === 0) return;
        
        const gl = this.gl;
        gl.useProgram(this.nodeProgram);
        
        // Prepare node data
        const positions = [];
        const colors = [];
        const radii = [];
        const borderWidths = [];
        const borderColors = [];
        
        nodes.forEach(node => {
          positions.push(node.x, node.y);
          
          const color = this.hexToRgb(getNodeColor(node));
          colors.push(...color);
          
          const radius = nodeSize(node);
          radii.push(radius);
          
          // Border styling
          if (node.suspicious) {
            borderWidths.push(3);
            borderColors.push(...this.hexToRgb('#7f1d1d'));
          } else if (radius > 12) {
            borderWidths.push(2);
            borderColors.push(...this.hexToRgb('#ffffff'));
          } else {
            borderWidths.push(0);
            borderColors.push(...color);
          }
        });
        
        // Set uniforms
        const resolutionLocation = gl.getUniformLocation(this.nodeProgram, 'u_resolution');
        if (resolutionLocation) {
          gl.uniform2f(resolutionLocation, width, height);
        }
        
        // Set attributes manually with proper error checking
        const positionLocation = gl.getAttribLocation(this.nodeProgram, 'a_position');
        if (positionLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.position);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }
        
        const colorLocation = gl.getAttribLocation(this.nodeProgram, 'a_color');
        if (colorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.color);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(colorLocation);
          gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        const radiusLocation = gl.getAttribLocation(this.nodeProgram, 'a_radius');
        if (radiusLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.radius);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(radii), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(radiusLocation);
          gl.vertexAttribPointer(radiusLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        const borderWidthLocation = gl.getAttribLocation(this.nodeProgram, 'a_borderWidth');
        if (borderWidthLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.borderWidth);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(borderWidths), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(borderWidthLocation);
          gl.vertexAttribPointer(borderWidthLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        const borderColorLocation = gl.getAttribLocation(this.nodeProgram, 'a_borderColor');
        if (borderColorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.borderColor);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(borderColors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(borderColorLocation);
          gl.vertexAttribPointer(borderColorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        // Draw nodes as points
        gl.drawArrays(gl.POINTS, 0, nodes.length);
      }

      setAttribute(program, name, data, size) {
        const gl = this.gl;
        const location = gl.getAttribLocation(program, name);
        const buffer = name.includes('position') ? this.nodeBuffers.position :
                       name.includes('color') ? this.nodeBuffers.color :
                       name.includes('radius') ? this.nodeBuffers.radius :
                       name.includes('borderWidth') ? this.nodeBuffers.borderWidth :
                       name.includes('borderColor') ? this.nodeBuffers.borderColor :
                       this.edgeBuffers.position;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);
      }

      renderLabels(nodes, width, height) {
        // CRITICAL FIX: Cannot create 2D context on canvas with WebGL context
        // Instead, create a temporary overlay canvas for text rendering
        const overlayCanvas = document.createElement('canvas');
        overlayCanvas.width = width;
        overlayCanvas.height = height;
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '1';
        
        const ctx = overlayCanvas.getContext('2d');
        if (!ctx) return;
        
        ctx.save();
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#1f2937';
        
        nodes.forEach(node => {
          const radius = nodeSize(node);
          if (radius > 8) {
            const label = (node.label || '').substring(0, 20);
            ctx.fillText(label, node.x, node.y - radius - 5);
          }
        });
        
        ctx.restore();
        
        // Replace any existing overlay
        const existingOverlay = this.canvas.parentNode.querySelector('.text-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // Add the overlay
        overlayCanvas.className = 'text-overlay';
        this.canvas.parentNode.appendChild(overlayCanvas);
      }

      cleanup() {
        if (!this.initialized) return;
        
        const gl = this.gl;
        Object.values(this.edgeBuffers).forEach(buffer => gl.deleteBuffer(buffer));
        Object.values(this.nodeBuffers).forEach(buffer => gl.deleteBuffer(buffer));
        
        if (this.edgeProgram) gl.deleteProgram(this.edgeProgram);
        if (this.nodeProgram) gl.deleteProgram(this.nodeProgram);
      }
    }

    // =========================
    // Layouts & drawing (GPU-accelerated)
    // =========================
    function applyForceLayout() {
      const centerX = canvas.width / 2, centerY = canvas.height / 2;
      nodes.forEach(node => {
        nodes.forEach(other => {
          if (node === other) return;
          const dx = node.x - other.x, dy = node.y - other.y;
          const dist = Math.sqrt(dx*dx + dy*dy) || 1;
          const force = Math.min(1000 / (dist*dist), 10);
          node.vx += (dx / dist) * force;
          node.vy += (dy / dist) * force;
        });
        graphData.links.forEach(link => {
          const source = nodes.find(n => n.id === link.source);
          const target = nodes.find(n => n.id === link.target);
          if (!source || !target) return;
          if (node === source) {
            const dx = target.x - source.x, dy = target.y - source.y;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const force = (dist - 150) * 0.05;
            node.vx += (dx / dist) * force;
            node.vy += (dy / dist) * force;
          }
        });
        node.vx += (centerX - node.x) * 0.002;
        node.vy += (centerY - node.y) * 0.002;
        node.vx *= 0.85; node.vy *= 0.85;
        node.x += node.vx; node.y += node.vy;
        const margin = 30;
        node.x = Math.max(margin, Math.min(canvas.width - margin, node.x));
        node.y = Math.max(margin, Math.min(canvas.height - margin, node.y));
      });
    }

    function initializeVisualization() {
      if (!graphData || graphData.nodes.length === 0) {
        if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      nodes = graphData.nodes.map(n => ({
        ...n,
        x: canvas.width/2 + (Math.random()-0.5)*100,
        y: canvas.height/2 + (Math.random()-0.5)*100,
        vx: 0, vy: 0
      }));

      // Update global nodes reference for WebGL renderer
      window.nodes = nodes;

      // CRITICAL FIX: Initialize GPU renderer FIRST, before any 2D context creation
      // This prevents the "Canvas already has a 2D context" error
      if (!gpuRenderer) {
        console.log('Attempting GPU renderer initialization...');
        gpuRenderer = new GPUNetworkRenderer(canvas);
        
        if (!gpuRenderer || !gpuRenderer.initialized) {
          console.log('GPU renderer failed, will use CPU rendering');
          gpuRenderer = null;
          // Only create 2D context if WebGL failed
          if (!ctx) {
            if (!gl && !gpuRenderer) {
              ctx = canvas.getContext('2d');
              canvas.__ctxType = '2d';
            }
          }
        }
      }

      startAnimation();
    }

    function startAnimation() {
      if (animationFrame) cancelAnimationFrame(animationFrame);
      let iteration = 0, maxIterations = 200;
      function animate() {
        if (iteration++ > maxIterations) return;
        applyForceLayout(); drawNetwork();
        animationFrame = requestAnimationFrame(animate);
      }
      animate();
    }

    function getNodeColor(node) {
      if (node.suspicious) return '#dc2626';
      if (communities && communities.communities.has(node.id)) {
        const cid = communities.communities.get(node.id);
        return communityColors[cid % communityColors.length];
      }
      if (node.type === 'user') return node.verified ? '#3b82f6' : '#8b5cf6';
      if (node.type === 'location') return '#f59e0b'; // Orange for locations
      return '#10b981'; // Green for hashtags
    }

    function nodeSize(n) {
      const sizeBy = nodeSizeBySelect.value;
      
      switch (sizeBy) {
        case 'degree':
          const degree = n.degree || 0;
          return Math.min(5 + Math.sqrt(degree) * 3, 30);
        
        case 'followers':
          if (n.type === 'user') {
            return Math.min(5 + Math.log((n.followers || 0) + 1) * 1.5, 25);
          } else {
            // For hashtags and locations, size by count
            return Math.min(5 + (n.count || 1) * 1.5, 25);
          }
        
        case 'uniform':
          return 8;
        
        default:
          return 8;
      }
    }

    function drawNetwork() {
      // Clean up any existing overlays before redrawing
      cleanupOverlays();
      
      // Try GPU rendering first, fallback to CPU if needed
      if (gpuRenderer && gpuRenderer.initialized) {
        const success = gpuRenderer.render(nodes, graphData.links, canvas.width, canvas.height);
        if (success) {
          // Render labels using Canvas 2D (text rendering in WebGL is complex)
          gpuRenderer.renderLabels(nodes, canvas.width, canvas.height);
          updateRenderingIndicator(true);
          return;
        }
      }
      
      // Fallback to CPU rendering
      drawNetworkCPU();
      updateRenderingIndicator(false);
    }

    function cleanupOverlays() {
      // Remove any existing overlay canvases
      const container = canvas.parentNode;
      const overlays = container.querySelectorAll('.text-overlay, .highlight-overlay, .search-highlight-overlay, .hover-overlay');
      overlays.forEach(overlay => overlay.remove());
    }

    function updateRenderingIndicator(isGPU) {
      if (isGPU) {
        renderingIndicator.textContent = '🚀 GPU rendering';
        renderingIndicator.style.color = '#10b981';
      } else {
        renderingIndicator.textContent = '⚙ CPU rendering';
        renderingIndicator.style.color = '#f59e0b';
      }
    }

    function drawNetworkCPU() {
      // Create 2D context on demand if not already created
      if (!ctx) {
        if (!gl && !gpuRenderer) {
          ctx = canvas.getContext('2d');
          canvas.__ctxType = '2d';
        }
        if (!ctx) {
          console.error('Failed to create 2D context');
          return;
        }
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // edges
      graphData.links.forEach(link => {
        const s = nodes.find(n => n.id === link.source);
        const t = nodes.find(n => n.id === link.target);
        if (!s || !t) return;
        const w = link.weight || 1;
        ctx.lineWidth = Math.min(1 + w*0.5, 5);
        ctx.strokeStyle = '#d1d5db';
        ctx.globalAlpha = Math.min(0.3 + w*0.1, 0.8);
        ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(t.x, t.y); ctx.stroke();
        ctx.globalAlpha = 1;
      });

      // nodes
      nodes.forEach(n => {
        const r = nodeSize(n);
        ctx.fillStyle = getNodeColor(n);
        ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI*2); ctx.fill();

        if (r > 12 || n.suspicious) {
          ctx.strokeStyle = n.suspicious ? '#7f1d1d' : 'white';
          ctx.lineWidth = n.suspicious ? 3 : 2; ctx.stroke();
        }

        if (r > 8) {
          ctx.fillStyle = '#1f2937';
          ctx.font = `${Math.min(r*0.8, 12)}px sans-serif`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
          const label = (n.label || '').substring(0, 20);
          ctx.fillText(label, n.x, n.y - r - 5);
        }
      });
    }

    // =========================
    // Hover & Click UX
    // =========================
    function getNodeAt(x, y) {
      if (!nodes?.length) return null;
      let best = null, bestDist = Infinity;
      for (const n of nodes) {
        const r = nodeSize(n);
        const d = Math.hypot(x - n.x, y - n.y);
        if (d <= r && d < bestDist) { best = n; bestDist = d; }
      }
      return best;
    }

    function buildAdjacency(graph) {
      adjacency = new Map();
      graph.nodes.forEach(n => adjacency.set(n.id, new Set()));
      graph.links.forEach(l => {
        if (adjacency.has(l.source)) adjacency.get(l.source).add(l.target);
        if (adjacency.has(l.target)) adjacency.get(l.target).add(l.source);
      });
      graph.nodes.forEach(n => { n.degree = adjacency.get(n.id)?.size || 0; });
    }

    function postEngagement(p) {
      const s = p?.data?.stats || {};
      return (s.diggCount||0) + (s.commentCount||0) + (s.shareCount||0);
    }

    function getAllPostsForNode(node) {
      if (!filteredData?.length) return [];
      const out = [];
      if (node.type === 'user') {
        const wantId = (node.id + '').replace(/^u_/,'');
        for (const p of filteredData) {
          const a = p?.data?.author || {};
          if (String(a.id) === wantId || (a.uniqueId && node.label && a.uniqueId.toLowerCase() === node.label.toLowerCase())) {
            out.push(p);
          }
        }
      } else if (node.type === 'hashtag') {
        const wantId = (node.id + '').replace(/^h_/,'');
        const wantLabel = (node.label || '').toLowerCase();
        for (const p of filteredData) {
          const hs = p?.data?.challenges || [];
          if (hs.some(h => String(h.id) === wantId || (h.title && h.title.toLowerCase() === wantLabel))) out.push(p);
        }
      } else if (node.type === 'location') {
        const wantId = (node.id + '').replace(/^loc_/,'');
        const wantLabel = (node.label || '').toLowerCase();
        for (const p of filteredData) {
          const loc = p?.data?._instagram?.location;
          if (loc && (String(loc.pk) === wantId || (loc.name && loc.name.toLowerCase() === wantLabel))) {
            out.push(p);
          }
        }
      }
      out.sort((a,b)=>postEngagement(b)-postEngagement(a));
      return out;
    }

    function samplePostsForNode(node, limit=5) {
      return getAllPostsForNode(node).slice(0, limit);
    }

    function highlightNeighbors(node) {
      const nbs = adjacency.get(node.id) || new Set();
      
      // For GPU rendering, we need to render the highlight effect
      if (gpuRenderer && gpuRenderer.initialized) {
        // Create highlight data for GPU rendering
        const highlightNodes = [];
        for (const id of nbs) {
          const nb = idToNode.get(id); 
          if (!nb) continue;
          highlightNodes.push({
            x: nb.x,
            y: nb.y,
            radius: nodeSize(nb) + 8,
            color: [1.0, 0.96, 0.42], // #fde68a in RGB
            alpha: 0.15
          });
        }
        renderHighlightGlow(highlightNodes, node, nbs);
      } else {
        // Fallback to CPU rendering - highlight neighbor nodes
      ctx.save(); ctx.globalAlpha = 0.15; ctx.fillStyle = '#fde68a';
      for (const id of nbs) {
        const nb = idToNode.get(id); if (!nb) continue;
        ctx.beginPath(); ctx.arc(nb.x, nb.y, nodeSize(nb)+8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
        
        // Highlight connected edges
        ctx.save();
        graphData.links.forEach(link => {
          const isConnected = (link.source === node.id && nbs.has(link.target)) ||
                             (link.target === node.id && nbs.has(link.source));
          if (!isConnected) return;
          
          const s = nodes.find(n => n.id === link.source);
          const t = nodes.find(n => n.id === link.target);
          if (!s || !t) return;
          
          const w = link.weight || 1;
          ctx.lineWidth = Math.min(2 + w*0.5, 6);
          ctx.strokeStyle = '#fbbf24'; // Amber color for highlighted edges
          ctx.globalAlpha = 0.8;
          ctx.beginPath(); 
          ctx.moveTo(s.x, s.y); 
          ctx.lineTo(t.x, t.y); 
          ctx.stroke();
        });
        ctx.restore();
      }
    }

    function renderHighlightGlow(highlightNodes, node, nbs) {
      // CRITICAL FIX: Cannot create 2D context on canvas with WebGL context
      // Create a temporary overlay canvas for highlight effects
      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.width = canvas.width;
      overlayCanvas.height = canvas.height;
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.pointerEvents = 'none';
      overlayCanvas.style.zIndex = '2';
      
      const tempCtx = overlayCanvas.getContext('2d');
      
      // Draw highlighted edges first (so they appear behind nodes)
      if (node && nbs) {
        tempCtx.save();
        graphData.links.forEach(link => {
          const isConnected = (link.source === node.id && nbs.has(link.target)) ||
                             (link.target === node.id && nbs.has(link.source));
          if (!isConnected) return;
          
          const s = nodes.find(n => n.id === link.source);
          const t = nodes.find(n => n.id === link.target);
          if (!s || !t) return;
          
          const w = link.weight || 1;
          tempCtx.lineWidth = Math.min(2 + w*0.5, 6);
          tempCtx.strokeStyle = '#fbbf24'; // Amber color for highlighted edges
          tempCtx.globalAlpha = 0.8;
          tempCtx.beginPath(); 
          tempCtx.moveTo(s.x, s.y); 
          tempCtx.lineTo(t.x, t.y); 
          tempCtx.stroke();
        });
        tempCtx.restore();
      }
      
      // Draw highlighted nodes
      tempCtx.save();
      highlightNodes.forEach(node => {
        tempCtx.globalAlpha = node.alpha;
        tempCtx.fillStyle = `rgb(${Math.floor(node.color[0]*255)}, ${Math.floor(node.color[1]*255)}, ${Math.floor(node.color[2]*255)})`;
        tempCtx.beginPath();
        tempCtx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        tempCtx.fill();
      });
      tempCtx.restore();
      
      // Remove any existing highlight overlay
      const existingHighlight = canvas.parentNode.querySelector('.highlight-overlay');
      if (existingHighlight) {
        existingHighlight.remove();
      }
      
      // Add the highlight overlay
      overlayCanvas.className = 'highlight-overlay';
      canvas.parentNode.appendChild(overlayCanvas);
    }

    canvas.addEventListener('mousemove', (e) => {
      if (!nodes?.length) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;

      const n = getNodeAt(x, y);
      if (n) {
        hoveredNode = n;
        canvas.classList.add('hovering');

        // tooltip content
        const deg = n.degree ?? 0;
        const label = n.label ?? n.id;
        let prefix = '';
        if (n.type === 'user') prefix = '@';
        else if (n.type === 'hashtag') prefix = '#';
        else if (n.type === 'location') prefix = '📍';
        
        const meta = (n.type==='user')
          ? `${n.verified?'Verified · ':''}${(n.followers||0).toLocaleString()} followers`
          : `${n.count||0} posts`;

        tooltipEl.innerHTML =
          `<div style="font-weight:600">${prefix}${label}</div>
           <div style="opacity:.85">${n.type} · degree ${deg}${meta ? ' · ' + meta : ''}</div>`;
        tooltipEl.style.display = 'block';

        // place tooltip
        const pad = 12;
        let tx = e.clientX + 12, ty = e.clientY + 12;
        const vw = window.innerWidth, vh = window.innerHeight;
        tooltipEl.style.left = tx + 'px'; tooltipEl.style.top = ty + 'px';
        const tb = tooltipEl.getBoundingClientRect();
        if (tx + tb.width + pad > vw) tooltipEl.style.left = (vw - tb.width - pad) + 'px';
        if (ty + tb.height + pad > vh) tooltipEl.style.top  = (vh - tb.height - pad) + 'px';

        // redraw with neighbor glow + ring
        drawNetwork();
        highlightNeighbors(n);
        
        // Draw hover ring using overlay to avoid context conflicts
        const hoverCanvas = document.createElement('canvas');
        hoverCanvas.width = canvas.width;
        hoverCanvas.height = canvas.height;
        hoverCanvas.style.position = 'absolute';
        hoverCanvas.style.top = '0';
        hoverCanvas.style.left = '0';
        hoverCanvas.style.pointerEvents = 'none';
        hoverCanvas.style.zIndex = '4';
        
        const hoverCtx = hoverCanvas.getContext('2d');
        hoverCtx.save(); 
        hoverCtx.strokeStyle = '#111827'; 
        hoverCtx.lineWidth = 2; 
        hoverCtx.globalAlpha = 0.6;
        hoverCtx.beginPath(); 
        hoverCtx.arc(n.x, n.y, nodeSize(n)+4, 0, Math.PI*2); 
        hoverCtx.stroke(); 
        hoverCtx.restore();
        
        // Remove any existing hover overlay
        const existingHover = canvas.parentNode.querySelector('.hover-overlay');
        if (existingHover) {
          existingHover.remove();
        }
        
        // Add the hover overlay
        hoverCanvas.className = 'hover-overlay';
        canvas.parentNode.appendChild(hoverCanvas);
      } else {
        hoveredNode = null;
        canvas.classList.remove('hovering');
        tooltipEl.style.display = 'none';
        drawNetwork();
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;

      let clicked = null, minDist = Infinity;
      nodes.forEach(n => {
        const r = nodeSize(n);
        const d = Math.hypot(x - n.x, y - n.y);
        if (d < r && d < minDist) { clicked = n; minDist = d; }
      });

      if (clicked) {
        showNodeInfo(clicked);   // keep sidebar
        openNodeModal(clicked);  // new rich modal
      }
    });

    function openNodeModal(node) {
      let prefix = '';
      if (node.type === 'user') prefix = '@';
      else if (node.type === 'hashtag') prefix = '#';
      else if (node.type === 'location') prefix = '📍';
      modalTitle.textContent = `${prefix}${node.label || node.id}`;

      const nbs = Array.from(adjacency.get(node.id) || []);
      const neighborHTML = nbs.slice(0, 14).map(id => {
        const lab = idToNode.get(id)?.label || id;
        return `<code style="background:#f3f4f6; padding:.15rem .35rem; border-radius:6px; margin:.12rem; display:inline-block;">${lab}</code>`;
      }).join('');

      // Get all posts for hashtag and location nodes, sample for user nodes
      const posts = (node.type === 'hashtag' || node.type === 'location') ? getAllPostsForNode(node) : samplePostsForNode(node, 6);
      const postsHTML = posts.map(p => {
        const a = p?.data?.author || {};
        const platform = p.platform || 'unknown';
        
        // Platform-specific URLs and icons
        let profileUrl, postUrl, platformIcon;
        if (platform === 'instagram') {
          profileUrl = a?.uniqueId ? `https://www.instagram.com/${a.uniqueId}` : null;
          const postCode = p.data?.code || p.data?.pk;
          postUrl = postCode ? `https://www.instagram.com/p/${postCode}` : null;
          platformIcon = '📷';
        } else if (platform === 'tiktok') {
          profileUrl = a?.uniqueId ? `https://www.tiktok.com/@${a.uniqueId}` : null;
          postUrl = p?.data?.webVideoUrl || p?.data?.shareUrl || null;
          platformIcon = '🎵';
        } else {
          profileUrl = null;
          postUrl = null;
          platformIcon = '❓';
        }
        
        const cap = (p?.data?.desc || '').slice(0, 220).replace(/</g,'<');
        const eng = postEngagement(p);
        const t = p?.data?.createTime ? new Date(p.data.createTime*1000).toLocaleString() : '';
        
        // Instagram-specific: location
        const location = p?.data?._instagram?.location;
        const locationText = location ? ` · 📍 ${location.name}` : '';
        
        return `<div style="padding:.6rem .6rem; border:1px solid #eee; border-radius:8px; margin:.45rem 0;">
          <div style="font-weight:600">${platformIcon} ${a.uniqueId ? '@'+a.uniqueId : '(unknown user)'} 
            ${profileUrl?` · <a href="${profileUrl}" target="_blank" rel="noopener" style="color:#2563eb; text-decoration:none;">profile</a>`:''}
            ${postUrl ? ` · <a href="${postUrl}" target="_blank" rel="noopener" style="color:#059669; text-decoration:none;">view post</a>`:''}
          </div>
          <div style="opacity:.95">${cap}${cap.length===220?'…':''}</div>
          <div style="opacity:.7; margin-top:.2rem">time: ${t} · engagement: ${eng.toLocaleString()}${locationText}</div>
        </div>`;
      }).join('');

      const teach = (() => {
        const deg = node.degree ?? 0;
        if (deg >= 12) return `This is a high-degree ${node.type}. Hubs can shape attention flows. Are neighbors from diverse communities, or mostly one echo chamber?`;
        if (deg <= 1)  return `This ${node.type} has very few connections. Is it peripheral, new, or filtered out by thresholds?`;
        return `Mid-degree ${node.type}. Check neighbors and example posts to see whether it bridges topics or audiences.`;
      })();

      const postsSectionTitle = (node.type === 'hashtag' || node.type === 'location')
        ? `All posts (${posts.length})` 
        : `Example posts (${posts.length})`;

      const postsContainerStyle = (node.type === 'hashtag' || node.type === 'location') 
        ? `max-height:300px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:8px; padding:.5rem; background:#fafafa;`
        : '';

      modalBody.innerHTML = `
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:8px;">
          <div><div class="small" style="color:#6b7280;">Type</div><div><b>${node.type}</b></div></div>
          <div><div class="small" style="color:#6b7280;">Degree</div><div><b>${node.degree ?? 0}</b></div></div>
          ${node.type==='user'
            ? `<div><div class="small" style="color:#6b7280;">Followers</div><div><b>${(node.followers||0).toLocaleString()}</b></div></div>
               <div><div class="small" style="color:#6b7280;">Verified</div><div><b>${node.verified? 'Yes':'No'}</b></div></div>`
            : node.type==='location'
            ? `<div><div class="small" style="color:#6b7280;">Posts at location</div><div><b>${node.count||0}</b></div></div>
               <div><div class="small" style="color:#6b7280;">Coordinates</div><div><b>${node.lat?.toFixed(4) || '?'}, ${node.lng?.toFixed(4) || '?'}</b></div></div>`
            : `<div><div class="small" style="color:#6b7280;">Usage count</div><div><b>${node.count||0}</b></div></div><div></div>`}
        </div>

        ${node.suspicious ? `
        <div class="warning-box" style="margin:.5rem 0;">
          <div style="font-weight:700; color:#991b1b; margin-bottom:.4rem;">⚠️ CIB DETECTED (Risk Score: ${node.cibScore}/100)</div>
          <div style="font-size:0.75rem; color:#7f1d1d; margin-bottom:.3rem;"><b>Indicators triggered:</b></div>
          <ul style="margin:0; padding-left:1.2rem; list-style:disc;">
            ${(node.cibReasons || []).map(reason => `<li style="margin:.15rem 0; color:#991b1b;">${reason}</li>`).join('')}
          </ul>
          <p style="margin-top:.4rem;"><strong>Note:</strong> These are behavioral indicators. Verify with manual inspection before drawing conclusions.</p>
        </div>
        ` : ''}

        <div class="small" style="background:#fff7ed; border:1px solid #fde7c7; padding:.6rem .7rem; border-radius:8px; margin:.4rem 0;">
          <b>Why it matters:</b> ${teach}
        </div>

        <div style="margin:.6rem 0 .25rem; font-weight:700;">Neighbors (${nbs.length})</div>
        <div>${neighborHTML || '<span class="small" style="color:#6b7280;">No neighbors</span>'}</div>

        <div style="margin:.9rem 0 .35rem; font-weight:700;">${postsSectionTitle}</div>
        <div style="${postsContainerStyle}">
          ${postsHTML || '<div class="small" style="color:#6b7280;">No posts found for this node given current filters.</div>'}
        </div>
        ${(node.type === 'hashtag' || node.type === 'location') && posts.length > 0 ? 
          `<div class="small" style="color:#6b7280; margin-top:.25rem; text-align:center;">Scroll to see all ${posts.length} posts</div>` : ''}
      `;
      modalEl.style.display = 'flex';
    }
    modalClose.addEventListener('click', ()=> modalEl.style.display = 'none');
    modalEl.addEventListener('click', (e)=> { if (e.target === modalEl) modalEl.style.display = 'none'; });

    function showNodeInfo(node) {
      let html = `<div class="info-row"><span class="info-label">Label:</span> <span class="info-value">${node.label}</span></div>`;
      html += `<div class="info-row"><span class="info-label">Type:</span> <span class="info-value">${node.type}</span></div>`;
      if (node.degree !== undefined) html += `<div class="info-row"><span class="info-label">Degree:</span> <span class="info-value">${node.degree}</span></div>`;
      if (node.followers !== undefined) html += `<div class="info-row"><span class="info-label">Followers:</span> <span class="info-value">${(node.followers||0).toLocaleString()}</span></div>`;
      if (node.count !== undefined) html += `<div class="info-row"><span class="info-label">Usage:</span> <span class="info-value">${node.count} posts</span></div>`;
      if (node.suspicious) {
        html += `<div class="info-row"><span class="cib-indicator">⚠ SUSPICIOUS ACTIVITY</span></div>`;
        if (node.cibScore) html += `<div class="info-row"><span class="info-label">CIB Score:</span> <span class="cib-score">${node.cibScore}/100</span></div>`;
      }
      if (communities && communities.communities.has(node.id)) {
        const cid = communities.communities.get(node.id);
        html += `<div class="info-row"><span class="info-label">Community:</span> <span class="info-value">#${cid + 1}</span></div>`;
      }
      if (node.verified) html += `<div class="info-row" style="color:#2563eb; font-weight: 600;">✓ Verified</div>`;
      nodeDetails.innerHTML = html;
      nodeInfo.style.display = 'block';
    }
    closeInfo.addEventListener('click', ()=> { nodeInfo.style.display = 'none'; });

    // =========================
    // Communities button
    // =========================
    cibBtn.addEventListener('click', detectCIB);

    detectBtn.addEventListener('click', () => {
      if (!graphData || graphData.nodes.length === 0) return;
      loading.classList.add('active');
      loadingText.textContent = 'Detecting communities...';
      setTimeout(() => {
        communities = detectCommunities(graphData);
        if (communities) document.getElementById('stat-communities').textContent = communities.count;
        drawNetwork();
        loading.classList.remove('active');
        updateCoach();
      }, 100);
    });

    // =========================
    // Controls wiring
    // =========================
    networkTypeSelect.addEventListener('change', updateNetwork);
    nodeSizeBySelect.addEventListener('change', () => {
      if (nodes.length > 0) drawNetwork();
    });
    engagementFilter.addEventListener('input', (e) => {
      const value = e.target.value; engagementValue.textContent = `${value}+ interactions`;
      updateNetwork();
    });
    dateStart.addEventListener('change', updateNetwork);
    dateEnd.addEventListener('change', updateNetwork);

    exportBtn.addEventListener('click', () => {
      if (!graphData) return;
      const exportData = {
        ...graphData,
        metrics: networkMetrics,
        communities: communities ? { count: communities.count, assignments: Array.from(communities.communities.entries()) } : null,
        cibDetection: cibDetection ? {
          suspiciousUsers: Array.from(cibDetection.suspiciousUsers),
          indicators: cibDetection.indicators,
          userScores: Array.from(cibDetection.userScores.entries()),
          userReasons: Array.from(cibDetection.userReasons.entries())
        } : null
      };
      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url; link.download = `network_analysis_${Date.now()}.json`; link.click();
      URL.revokeObjectURL(url);
    });

    searchInput.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      if (!term || !nodes.length) { drawNetwork(); return; }
      drawNetwork();
      const matches = nodes.filter(n => (n.label || '').toLowerCase().includes(term));
      
      // Draw search highlights using overlay canvas to avoid context conflicts
      const highlightCanvas = document.createElement('canvas');
      highlightCanvas.width = canvas.width;
      highlightCanvas.height = canvas.height;
      highlightCanvas.style.position = 'absolute';
      highlightCanvas.style.top = '0';
      highlightCanvas.style.left = '0';
      highlightCanvas.style.pointerEvents = 'none';
      highlightCanvas.style.zIndex = '3';
      
      const highlightCtx = highlightCanvas.getContext('2d');
      highlightCtx.strokeStyle = '#ef4444'; 
      highlightCtx.lineWidth = 3;
      matches.forEach(n => { 
        const r = nodeSize(n); 
        highlightCtx.beginPath(); 
        highlightCtx.arc(n.x, n.y, r+3, 0, Math.PI*2); 
        highlightCtx.stroke(); 
      });
      
      // Remove any existing search highlight overlay
      const existingSearchHighlight = canvas.parentNode.querySelector('.search-highlight-overlay');
      if (existingSearchHighlight) {
        existingSearchHighlight.remove();
      }
      
      // Add the search highlight overlay
      highlightCanvas.className = 'search-highlight-overlay';
      canvas.parentNode.appendChild(highlightCanvas);
    });

    window.addEventListener('resize', () => {
      if (graphData && graphData.nodes.length > 0) initializeVisualization();
    });

    // =========================
    // Teaching coach (dynamic)
    // =========================
    function updateCoach() {
      const coach = document.getElementById('edu-coach');
      if (!graphData || !graphData.nodes.length) {
        coach.innerHTML = `<p><b>Guillen</b> load data, then hover or click nodes.</p>`;
        return;
      }
      const dens = networkMetrics?.density ?? 0;
      const commCount = communities?.count ?? 0;

      let hint = '';
      const networkType = networkTypeSelect.value;
      if (networkType === 'coHashtag') {
        hint = `You're looking at hashtag co-occurrence. Dense cliques can reflect coordinated messaging or just memes — check example posts in the modal.`;
      } else if (networkType === 'userHashtag') {
        hint = `This is a bipartite user↔hashtag graph. Click a hashtag hub: who uses it? One community or many?`;
      } else if (networkType === 'mention') {
        hint = `Mention networks highlight attention-giving. Are hubs amplifying each other, or bridging clusters?`;
      } else if (networkType === 'photoTag') {
        hint = `📷 Instagram photo tag network: see who tags whom in photos. This reveals collaboration and relationship patterns.`;
      } else if (networkType === 'location') {
        hint = `📍 Instagram location network: where are users posting from? Shared locations can indicate coordinated campaigns or events.`;
      } else {
        hint = `Hashtag usage view shows which tags carry engagement; hubs suggest narrative anchors.`;
      }

      const densNote = (parseFloat(dens) >= 0.15)
        ? `High density (${dens}) ⇒ tight interlinking. Inspect hubs for templated captions or synchronized timing.`
        : `Lower density (${dens}) ⇒ fragmented/diverse activity. Look for bridges and outliers.`;

      const commNote = commCount
        ? `Detected <b>${commCount}</b> community${commCount>1?'ies':''}. Compare top tags/posts across them for narrative splits.`
        : `Run “Detect Communities” to see sub-audiences.`;

      coach.innerHTML = `
        <p><b>Guillen:</b> ${hint}</p>
        <p>${densNote}</p>
        <p>${commNote}</p>
      `;
    }
  </script>
</body>
</html>
