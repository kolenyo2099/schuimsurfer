<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>SchuimSurfer</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: #f9fafb;
      height: 100vh;
      overflow: hidden;
    }

    .container { display: flex; flex-direction: column; height: 100vh; }

    .header {
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 1rem 1.5rem;
    }

    .header-top { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; }

    h1 { font-size: 1.5rem; color: #111827; margin-bottom: 0.25rem; }

    .subtitle { font-size: 0.875rem; color: #6b7280; }

    .upload-btn {
      display: inline-flex; align-items: center; gap: 0.5rem;
      padding: 0.625rem 1rem; background: #2563eb; color: white;
      border: none; border-radius: 0.5rem; cursor: pointer; font-size: 0.875rem; font-weight: 500; transition: background 0.2s;
    }
    .upload-btn:hover { background: #1d4ed8; }

    .stats-grid {
      display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem; margin-bottom: 1rem;
    }

    .stat-card { padding: 0.75rem; border-radius: 0.5rem; }
    .stat-card.blue { background: #eff6ff; }    .blue .stat-label { color: #2563eb; }    .blue .stat-value { color: #1e3a8a; }
    .stat-card.purple { background: #f5f3ff; }  .purple .stat-label { color: #7c3aed; }  .purple .stat-value { color: #5b21b6; }
    .stat-card.green { background: #f0fdf4; }   .green .stat-label { color: #059669; }   .green .stat-value { color: #065f46; }
    .stat-card.orange { background: #fff7ed; }  .orange .stat-label { color: #ea580c; }  .orange .stat-value { color: #9a3412; }
    .stat-card.gray { background: #f3f4f6; }    .gray .stat-label { color: #4b5563; }    .gray .stat-value { color: #1f2937; }
    .stat-card.pink { background: #fdf2f8; }    .pink .stat-label { color: #db2777; }    .pink .stat-value { color: #9f1239; }
    .stat-card.yellow { background: #fefce8; }  .yellow .stat-label { color: #ca8a04; }  .yellow .stat-value { color: #854d0e; }
    .stat-card.cyan { background: #ecfeff; }    .cyan .stat-label { color: #0891b2; }    .cyan .stat-value { color: #155e75; }
    .stat-card.red { background: #fef2f2; }     .red .stat-label { color: #dc2626; }     .red .stat-value { color: #991b1b; }

    .stat-label {
      font-size: 0.75rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 0.25rem;
    }
    .stat-value { font-size: 1.5rem; font-weight: 700; }

    .main-content { display: flex; flex: 1; overflow: hidden; }
    .sidebar { width: 340px; background: white; border-right: 1px solid #e5e7eb; padding: 1.5rem; overflow-y: auto; }

    .control-group { margin-bottom: 1.5rem; }
    .control-label {
      display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem;
    }
    select, input[type="text"], input[type="date"], input[type="range"], input[type="number"] {
      width: 100%; padding: 0.5rem 0.75rem; border: 1px solid #d1d5db; border-radius: 0.5rem; font-size: 0.875rem;
    }
    select:focus, input:focus { outline: none; border-color: #2563eb; box-shadow: 0 0 0 3px rgba(37,99,235,0.1); }

    .date-range { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .date-input-wrapper { display: flex; flex-direction: column; gap: 0.25rem; }
    .date-label { font-size: 0.75rem; color: #6b7280; }
    .range-value { font-size: 0.875rem; color: #6b7280; margin-top: 0.25rem; }

    .btn {
      width: 100%; display: flex; align-items: center; justify-content: center; gap: 0.5rem;
      padding: 0.625rem 1rem; border: none; border-radius: 0.5rem; font-size: 0.875rem; font-weight: 500; cursor: pointer; transition: background 0.2s;
    }
    .btn-export { background: #059669; color: white; } .btn-export:hover:not(:disabled) { background: #047857; }
    .btn-detect { background: #7c3aed; color: white; margin-bottom: 0.5rem; } .btn-detect:hover:not(:disabled) { background: #6d28d9; }
    .btn-cib { background: #dc2626; color: white; margin-bottom: 1rem; } .btn-cib:hover:not(:disabled) { background: #b91c1c; }
    .btn:disabled { background: #d1d5db; cursor: not-allowed; }

    .info-panel { background: #f9fafb; padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
    .info-header { display: flex; justify-content: space-between; align-items: start; margin-bottom: 0.75rem; }
    .info-title { font-weight: 600; color: #111827; }
    .close-btn { background: none; border: none; cursor: pointer; color: #6b7280; padding: 0; }
    .info-row { font-size: 0.875rem; margin-bottom: 0.5rem; }
    .info-label { color: #6b7280; }
    .info-value { font-weight: 500; }

    .legend { background: #f9fafb; padding: 1rem; border-radius: 0.5rem; border: 1px solid #e5e7eb; }
    .legend-title { font-weight: 600; color: #111827; margin-bottom: 0.75rem; }
    .legend-item { display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; margin-bottom: 0.5rem; }
    .legend-dot { width: 1rem; height: 1rem; border-radius: 50%; }
    .legend-note { font-size: 0.75rem; color: #6b7280; margin-top: 0.75rem; }

    .canvas-container { flex: 1; background: white; position: relative; }
    #network-canvas { width: 100%; height: 100%; cursor: pointer; }
    #network-canvas.hovering { cursor: pointer; }

    .empty-state {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;
    }
    .empty-icon { width: 48px; height: 48px; margin: 0 auto 1rem; color: #9ca3af; }
    .empty-title { font-size: 1.25rem; font-weight: 600; color: #374151; margin-bottom: 0.5rem; }
    .empty-text { color: #6b7280; }

    .loading {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,.5);
      display: none; align-items: center; justify-content: center; z-index: 1000; flex-direction: column;
    }
    .loading.active { display: flex; }
    .spinner { width: 50px; height: 50px; border: 4px solid #f3f4f6; border-top: 4px solid #2563eb; border-radius: 50%;
      animation: spin 1s linear infinite; margin-bottom: 1rem; }
    .loading-text { color: white; font-size: 1rem; font-weight: 500; }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    input[type="file"] { display: none; }

    .metrics-list { list-style: none; }
    .metrics-list li {
      display: flex; justify-content: space-between; padding: 0.5rem 0; border-bottom: 1px solid #e5e7eb; font-size: 0.875rem;
    }
    .metrics-list li:last-child { border-bottom: none; }
    .metric-name { color: #6b7280; }
    .metric-value { font-weight: 600; color: #111827; }

    .section-divider { height: 1px; background: #e5e7eb; margin: 1.5rem 0; }

    .warning-box { background: #fef2f2; border: 1px solid #fecaca; border-radius: 0.5rem; padding: 0.75rem; margin-top: 0.5rem; }
    .warning-box p { font-size: 0.75rem; color: #991b1b; line-height: 1.4; }
    .cib-indicator { display: inline-block; padding: 0.125rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; font-weight: 600; color: white; background: #dc2626; }
    .cib-score { font-weight: 700; color: #dc2626; }

    .small { font-size: 12px; color: #374151; }
    
    /* Advanced Settings Styling */
    .settings-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 0.75rem;
    }
    
    .setting-item label {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      cursor: help;
    }
    
    .setting-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #374151;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    
    .setting-item input[type="number"],
    .setting-item select {
      padding: 0.375rem 0.5rem;
      font-size: 0.875rem;
      border: 1px solid #d1d5db;
      border-radius: 0.375rem;
      width: 100%;
      background: white;
    }
    
    .setting-item input[type="number"]:focus,
    .setting-item select:focus {
      outline: none;
      border-color: #2563eb;
      box-shadow: 0 0 0 3px rgba(37,99,235,0.1);
    }
    
    .btn-settings:hover:not(:disabled) { background: #4b5563; }
    
    /* Help Button & Modal */
    .help-btn {
      display: inline-flex;
      align-items: center;
      gap: 0.375rem;
      padding: 0.5rem 0.875rem;
      background: #10b981;
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      font-size: 0.875rem;
      font-weight: 500;
      transition: background 0.2s;
    }
    
    .help-btn:hover {
      background: #059669;
    }
    
    .help-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      overflow: auto;
      padding: 2rem;
      animation: fadeIn 0.2s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .help-modal.active {
      display: flex;
      justify-content: center;
      align-items: flex-start;
    }
    
    .help-content {
      background: white;
      border-radius: 0.75rem;
      max-width: 900px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      position: relative;
      animation: slideUp 0.3s ease-out;
    }
    
    @keyframes slideUp {
      from { 
        opacity: 0;
        transform: translateY(20px);
      }
      to { 
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    .help-header {
      position: sticky;
      top: 0;
      background: white;
      border-bottom: 1px solid #e5e7eb;
      padding: 1.5rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
    }
    
    .help-title {
      font-size: 1.5rem;
      font-weight: 700;
      color: #111827;
    }
    
    .help-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      color: #6b7280;
      cursor: pointer;
      width: 2rem;
      height: 2rem;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 0.375rem;
      transition: background 0.2s;
    }
    
    .help-close:hover {
      background: #f3f4f6;
      color: #111827;
    }
    
    .help-body {
      padding: 2rem;
      line-height: 1.7;
      color: #374151;
    }
    
    .help-body h1 {
      font-size: 2rem;
      margin-top: 2rem;
      margin-bottom: 1rem;
      color: #111827;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.5rem;
    }
    
    .help-body h2 {
      font-size: 1.5rem;
      margin-top: 2rem;
      margin-bottom: 0.75rem;
      color: #111827;
    }
    
    .help-body h3 {
      font-size: 1.25rem;
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      color: #1f2937;
    }
    
    .help-body h4 {
      font-size: 1.1rem;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      color: #374151;
      font-weight: 600;
    }
    
    .help-body p {
      margin-bottom: 1rem;
    }
    
    .help-body ul, .help-body ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
    }
    
    .help-body li {
      margin-bottom: 0.5rem;
    }
    
    .help-body code {
      background: #f3f4f6;
      padding: 0.125rem 0.375rem;
      border-radius: 0.25rem;
      font-family: 'Courier New', monospace;
      font-size: 0.875em;
      color: #be123c;
    }
    
    .help-body pre {
      background: #1f2937;
      color: #f3f4f6;
      padding: 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      margin-bottom: 1rem;
    }
    
    .help-body pre code {
      background: transparent;
      color: inherit;
      padding: 0;
    }
    
    .help-body table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }
    
    .help-body th {
      background: #f9fafb;
      padding: 0.75rem;
      text-align: left;
      font-weight: 600;
      border: 1px solid #e5e7eb;
    }
    
    .help-body td {
      padding: 0.75rem;
      border: 1px solid #e5e7eb;
    }
    
    .help-body blockquote {
      border-left: 4px solid #10b981;
      padding-left: 1rem;
      margin: 1rem 0;
      color: #6b7280;
      font-style: italic;
    }
    
    .help-body a {
      color: #2563eb;
      text-decoration: none;
    }
    
    .help-body a:hover {
      text-decoration: underline;
    }
    
    .help-body hr {
      border: none;
      border-top: 1px solid #e5e7eb;
      margin: 2rem 0;
    }
    
    .help-body .emoji {
      font-style: normal;
    }
  </style>

  <!-- Transformers.js for Semantic Similarity Detection -->
  <script type="module">
    import { pipeline } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1';
    
    // Initialize model (loads once, then cached)
    let extractor = null;
    
    async function initEmbeddingModel() {
      if (!extractor) {
        console.log('Loading embedding model (Xenova/all-MiniLM-L6-v2, ~23MB)...');
        extractor = await pipeline('feature-extraction', 'Xenova/all-MiniLM-L6-v2');
        console.log('✓ Embedding model ready (384-dimensional vectors)');
      }
      return extractor;
    }
    
    // Generate embedding for text (384-dimensional normalized vector)
    async function getEmbedding(text) {
      const model = await initEmbeddingModel();
      const output = await model(text, { pooling: 'mean', normalize: true });
      return Array.from(output.data);
    }
    
    // Calculate cosine similarity (already normalized, so just dot product)
    function cosineSimilarity(vecA, vecB) {
      return vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
    }
    
    // Expose globally
    window.getEmbedding = getEmbedding;
    window.cosineSimilarity = cosineSimilarity;
    window.initEmbeddingModel = initEmbeddingModel;
  </script>
</head>
<body>
  <div class="container">
    <!-- Header -->
    <div class="header">
      <div class="header-top">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <div>
            <h1>Zeeschuim Surfer</h1>
            <div class="subtitle">
              Basic network analysis and CIB detection
              <span id="platform-indicator" style="margin-left:0.5rem; opacity:0.7;"></span>
              <span id="rendering-indicator" style="margin-left:0.5rem; opacity:0.7; font-size:0.75rem;"></span>
            </div>
          </div>
          <button id="help-btn" class="help-btn" title="View complete user guide">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
              <line x1="12" y1="17" x2="12.01" y2="17"></line>
            </svg>
            How to?
          </button>
        </div>
        <label class="upload-btn">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <span>Upload Zeeschuimer data (ndjson)</span>
          <input type="file" accept=".ndjson,.json" id="file-input">
        </label>
      </div>

      <div class="stats-grid" id="stats" style="display: none;">
        <div class="stat-card blue"><div class="stat-label">Posts</div><div class="stat-value" id="stat-posts">0</div></div>
        <div class="stat-card purple"><div class="stat-label">Users</div><div class="stat-value" id="stat-users">0</div></div>
        <div class="stat-card green"><div class="stat-label">Hashtags</div><div class="stat-value" id="stat-hashtags">0</div></div>
        <div class="stat-card orange"><div class="stat-label">Avg Engagement</div><div class="stat-value" id="stat-engagement">0</div></div>
        <div class="stat-card gray"><div class="stat-label">Network Nodes</div><div class="stat-value" id="stat-nodes">0</div></div>
        <div class="stat-card pink"><div class="stat-label">Network Edges</div><div class="stat-value" id="stat-edges">0</div></div>
        <div class="stat-card yellow"><div class="stat-label">Density</div><div class="stat-value" id="stat-density">0</div></div>
        <div class="stat-card cyan"><div class="stat-label">Communities</div><div class="stat-value" id="stat-communities">0</div></div>
        <div class="stat-card red"><div class="stat-label">Suspicious Accounts</div><div class="stat-value" id="stat-suspicious">0</div></div>
      </div>
    </div>

    <!-- Main Content -->
    <div class="main-content">
      <!-- Sidebar -->
      <div class="sidebar">
        <!-- Education panel -->
        <div class="info-panel" id="edu-panel" style="margin-bottom:1.5rem;">
          <div class="info-title" style="margin-bottom:.5rem;">Some useful info:</div>
          <div id="edu-basics" class="small">
            <p><b>Nodes</b> are users or hashtags; <b>edges</b> connect them (mentions, co-hashtags, etc.).</p>
            <p><b>Degree</b> = how many neighbors a node has. Hubs can shape attention; high-degree hashtags often mark narratives.</p>
            <p><b>Clustering</b> ≈ how connected a node's neighbors are. High clustering hints at tight echo chambers.</p>
            <p><b>Communities</b> are groups more connected inside than outside — useful to find sub-audiences or coordinated clusters.</p>
          </div>
          <div class="section-divider" style="margin:.75rem 0;"></div>
          <div id="edu-coach" class="small">
            <p><b>How to:</b> load data, pick a network type, then <i>hover</i> nodes for quick stats or <i>click</i> for deep-dive & example posts.</p>
          </div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6"></path>
              <path d="M17 12h6M1 12h6"></path>
            </svg>
            Network Type
          </label>
          <select id="network-type">
            <option value="mention">User Mentions Network</option>
            <option value="coHashtag">Hashtag Co-occurrence</option>
            <option value="userHashtag">User-Hashtag Network</option>
            <option value="hashtag">Hashtag Usage</option>
            <option value="photoTag" title="Instagram only: users tagged in photos">📷 Photo Tag Network (Instagram)</option>
            <option value="location" title="Instagram only: posts by location">📍 Location Network (Instagram)</option>
          </select>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <circle cx="12" cy="12" r="6"></circle>
              <circle cx="12" cy="12" r="2"></circle>
            </svg>
            Node Size By
          </label>
          <select id="node-size-by">
            <option value="degree">Degree (connections)</option>
            <option value="followers">Followers/Usage Count</option>
            <option value="uniform">Uniform Size</option>
          </select>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
              <line x1="16" y1="2" x2="16" y2="6"></line>
              <line x1="8" y1="2" x2="8" y2="6"></line>
              <line x1="3" y1="10" x2="21" y2="10"></line>
            </svg>
            Time Range Filter
          </label>
          <div class="date-range">
            <div class="date-input-wrapper">
              <label class="date-label">From</label>
              <input type="date" id="date-start">
            </div>
            <div class="date-input-wrapper">
              <label class="date-label">To</label>
              <input type="date" id="date-end">
            </div>
          </div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>
            </svg>
            Minimum Engagement
          </label>
          <input type="range" id="engagement-filter" min="0" max="10000" step="100" value="0">
          <div class="range-value" id="engagement-value">0+ interactions</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            CIB Detection Sensitivity
          </label>
          <input type="range" id="cib-threshold" min="1" max="10" step="1" value="5">
          <div class="range-value" id="threshold-value">Medium (5)</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="10"></circle>
              <polyline points="12 6 12 12 16 14"></polyline>
            </svg>
            Synchronized Posting Time Window
          </label>
          <input type="range" id="time-window" min="1" max="1800" step="1" value="300">
          <div class="range-value" id="time-window-value">5 minutes</div>
        </div>

        <div class="control-group">
          <label class="control-label">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
            Search
          </label>
          <input type="text" id="search-input" placeholder="Search nodes...">
        </div>

        <div class="control-group">
          <button class="btn btn-cib" id="cib-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>
            </svg>
            Detect Coordinated Behavior
          </button>
          <button class="btn btn-settings" id="cib-settings-btn" disabled style="background: #6b7280; margin-bottom: 0.5rem;">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6M17 12h6M1 12h6"></path>
            </svg>
            Advanced CIB Settings
          </button>
          <button class="btn btn-detect" id="detect-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="3"></circle>
              <path d="M12 1v6m0 6v6"></path>
              <path d="M17 12h6M1 12h6"></path>
            </svg>
            Detect Communities
          </button>
          <button class="btn btn-export" id="export-btn" disabled>
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
              <polyline points="7 10 12 15 17 10"></polyline>
              <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
            Export Network Data
          </button>
        </div>

        <div class="section-divider"></div>

        <!-- Advanced CIB Settings Panel -->
        <div class="info-panel" id="cib-settings-panel" style="display: none;">
          <div class="info-header">
            <div class="info-title">Advanced CIB Parameters</div>
            <button class="close-btn" id="close-cib-settings">✕</button>
          </div>
          
          <div style="font-size: 0.75rem; color: #6b7280; margin-bottom: 1rem;">
            Fine-tune detection thresholds. Hover over labels for explanations.
          </div>
          
          <div class="settings-grid">
            <div class="setting-item">
              <label title="Enable/disable AI-powered semantic similarity detection. Disable for faster processing on large datasets.">
                <span class="setting-label">🤖 Use Semantic Similarity</span>
                <select id="param-semantic-enabled">
                  <option value="true">Enabled (slower, more accurate)</option>
                  <option value="false">Disabled (faster)</option>
                </select>
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Cosine similarity threshold for AI-powered caption matching (0-1). Higher = stricter">
                <span class="setting-label">Semantic Threshold</span>
                <input type="number" id="param-semantic-threshold" min="0" max="1" step="0.05" value="0.85">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Jaccard similarity for 5-gram template matching (0-1). Higher = stricter">
                <span class="setting-label">N-gram Overlap</span>
                <input type="number" id="param-ngram-threshold" min="0" max="1" step="0.05" value="0.3">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Levenshtein similarity for username matching (0-1). Higher = stricter">
                <span class="setting-label">Username Similarity</span>
                <input type="number" id="param-username-threshold" min="0" max="1" step="0.05" value="0.8">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="TF-IDF score threshold for rare hashtag detection (0-2). Higher = rarer hashtags only">
                <span class="setting-label">TF-IDF Threshold</span>
                <input type="number" id="param-tfidf-threshold" min="0" max="2" step="0.1" value="0.5">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Z-score threshold for high-volume detection (1-4). Higher = stricter">
                <span class="setting-label">Z-Score Threshold</span>
                <input type="number" id="param-zscore-threshold" min="1" max="4" step="0.5" value="2">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Minimum posts in time window to trigger burst detection (3-10)">
                <span class="setting-label">Burst Min Posts</span>
                <input type="number" id="param-burst-posts" min="3" max="10" step="1" value="5">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Coefficient of variation threshold for rhythm detection (0-0.5). Lower = more regular">
                <span class="setting-label">Rhythm CV Threshold</span>
                <input type="number" id="param-rhythm-cv" min="0" max="0.5" step="0.05" value="0.1">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Max posting gap in seconds for 24/7 detection (3600-14400). Lower = stricter">
                <span class="setting-label">Night Gap (seconds)</span>
                <input type="number" id="param-night-gap" min="3600" max="14400" step="1800" value="7200">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Min accounts in cluster for account creation detection (3-10)">
                <span class="setting-label">Cluster Min Size</span>
                <input type="number" id="param-cluster-size" min="3" max="10" step="1" value="5">
              </label>
            </div>
            
            <div class="setting-item">
              <label title="Score multiplier per indicator (0.1-0.5). Higher = more penalty for multiple indicators">
                <span class="setting-label">Cross-Indicator Bonus</span>
                <input type="number" id="param-cross-multiplier" min="0.1" max="0.5" step="0.05" value="0.3">
              </label>
            </div>
          </div>
          
          <button class="btn" id="reset-cib-params" style="background: #6b7280; color: white; margin-top: 1rem;">
            Reset to Defaults
          </button>
        </div>

        <!-- CIB Detection Results -->
        <div class="info-panel" id="cib-panel" style="display: none;">
          <div class="info-title" style="margin-bottom: 0.75rem;">CIB Detection Results</div>
          <div id="cib-results"></div>
          <div class="warning-box">
            <p><strong>Note:</strong> These are indicators, not proof. Legitimate activism and organic coordination may trigger signals. Always verify with manual inspection.</p>
          </div>
        </div>

        <!-- Network Metrics -->
        <div class="info-panel" id="metrics-panel" style="display: none;">
          <div class="info-title" style="margin-bottom: 0.75rem;">Network Metrics</div>
          <ul class="metrics-list" id="metrics-list"></ul>
        </div>

        <!-- Selected Node Info (sidebar) -->
        <div class="info-panel" id="node-info" style="display: none; margin-top: 1rem;">
          <div class="info-header">
            <div class="info-title">Node Details</div>
            <button class="close-btn" id="close-info">
              <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
          <div id="node-details"></div>
        </div>

        <!-- Legend -->
        <div class="legend" style="margin-top: 1rem;">
          <div class="legend-title">Legend</div>
          <div class="legend-item"><div class="legend-dot" style="background:#dc2626;"></div><span>Suspicious/CIB Account</span></div>
          <div class="legend-item"><div class="legend-dot blue" style="background:#3b82f6;"></div><span>Verified User</span></div>
          <div class="legend-item"><div class="legend-dot purple" style="background:#8b5cf6;"></div><span>Regular User</span></div>
          <div class="legend-item"><div class="legend-dot green" style="background:#10b981;"></div><span>Hashtag</span></div>
          <div class="legend-item"><div class="legend-dot" style="background:#f59e0b;"></div><span>Location (Instagram)</span></div>
          <div class="legend-note">Red nodes indicate accounts flagged as potentially coordinated based on behavioral indicators. Supports 🎵 TikTok, 📷 Instagram, and 🐦 Twitter/X data.</div>
        </div>

      </div>

      <!-- Canvas area -->
      <div class="canvas-container">
        <canvas id="network-canvas"></canvas>

        <!-- Hover tooltip (simple) -->
        <div id="node-tooltip" style="
          position:absolute; pointer-events:none; display:none;
          background:#111827; color:#fff; padding:.4rem .6rem; border-radius:.375rem;
          font-size:12px; box-shadow:0 6px 20px rgba(0,0,0,.2); z-index:2;">
        </div>

        <!-- Click modal (rich) -->
        <div id="node-modal" style="
          position:fixed; inset:0; background:rgba(0,0,0,.5); display:none;
          align-items:center; justify-content:center; z-index:2000;">
          <div style="width:min(780px,92vw); max-height:80vh; overflow:auto; background:#fff; border-radius:12px;
                      box-shadow:0 20px 60px rgba(0,0,0,.35);">
            <div style="padding:16px 18px; border-bottom:1px solid #eee; display:flex; align-items:center; justify-content:space-between;">
              <div id="modal-title" style="font-weight:700; font-size:16px;">Node</div>
              <button id="modal-close" style="border:none; background:#f3f4f6; padding:.4rem .6rem; border-radius:8px; cursor:pointer;">Close</button>
            </div>
            <div id="modal-body" style="padding:16px 18px; font-size:14px;"></div>
          </div>
        </div>

        <div class="empty-state" id="empty-state">
          <svg class="empty-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="17 8 12 3 7 8"></polyline>
            <line x1="12" y1="3" x2="12" y2="15"></line>
          </svg>
          <div class="empty-title">No Data Loaded</div>
          <div class="empty-text">Upload a Zeeschuimer NDJSON file to get started</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading" id="loading">
    <div class="spinner"></div>
    <div class="loading-text" id="loading-text">Processing...</div>
  </div>

  <script>
    // =========================
    // Global state
    // =========================
    let rawData = [];
    let filteredData = [];
    let graphData = null;
    let nodes = [];
    let communities = null;
    let cibDetection = null;
    let animationFrame = null;
    let networkMetrics = null;

    // Expose nodes globally for WebGL renderer access
    window.nodes = nodes;

    // Hover & modal helpers / indexes
    let idToNode = new Map();     // node.id -> node (with x,y)
    let adjacency = new Map();    // node.id -> Set(neighborIds)
    let hoveredNode = null;

    // =========================
    // Platform Detection & Normalization
    // =========================
    function detectPlatform(post) {
      const platform = post.source_platform || '';
      if (platform.includes('instagram')) return 'instagram';
      if (platform.includes('tiktok')) return 'tiktok';
      if (platform.includes('twitter') || platform.includes('x.com')) return 'twitter';
      return 'unknown';
    }

    // Extract hashtags from text (for Instagram)
    function extractHashtagsFromText(text) {
      if (!text) return [];
      const matches = text.match(/#(\w+)/g) || [];
      return matches.map((tag, idx) => ({
        id: `ig_${tag.substring(1)}_${idx}`, // unique ID for each hashtag
        title: tag.substring(1) // remove the #
      }));
    }

    // Extract mentions from text (for Instagram)
    function extractMentionsFromText(text) {
      if (!text) return [];
      const matches = text.match(/@(\w+)/g) || [];
      return matches.map(mention => ({
        username: mention.substring(1) // remove the @
      }));
    }

    // Normalize post data across platforms
    function normalizePost(post) {
      const platform = detectPlatform(post);
      const normalized = { ...post, platform };

      if (platform === 'instagram') {
        // Normalize Instagram data to TikTok-like structure
        const ig = post.data;
        const owner = ig.owner || ig.user || {};
        const caption = ig.caption?.text || '';
        
        normalized.data = {
          ...ig,
          // Author info
          author: {
            id: owner.pk || owner.id,
            uniqueId: owner.username,
            nickname: owner.full_name || owner.username,
            verified: owner.is_verified || false
          },
          // Timestamp
          createTime: ig.taken_at,
          // Caption
          desc: caption,
          // Extract hashtags from caption
          challenges: extractHashtagsFromText(caption),
          // Extract mentions from caption
          textExtra: extractMentionsFromText(caption).map(m => ({
            type: 0,
            userUniqueId: m.username,
            userId: null // Instagram doesn't provide user IDs in mentions
          })),
          // Engagement stats
          stats: {
            diggCount: ig.like_count || 0,
            commentCount: ig.comment_count || 0,
            shareCount: 0, // Instagram doesn't expose share count
            playCount: ig.view_count || 0
          },
          // Author stats (not available in Instagram post data)
          authorStats: {
            followerCount: 0
          },
          // Keep Instagram-specific fields
          _instagram: {
            location: ig.location,
            usertags: ig.usertags,
            carousel_media: ig.carousel_media
          }
        };
      } else if (platform === 'tiktok') {
        // TikTok data is already in the right format, just mark platform
        normalized.data = { ...post.data };
      } else if (platform === 'twitter') {
        // Normalize Twitter/X data to TikTok-like structure
        const tweet = post.data;
        const userResult = tweet.core?.user_results?.result || {};
        const userCore = userResult.core || {};
        const userLegacy = userResult.legacy || {};
        const tweetLegacy = tweet.legacy || {};
        
        // Parse Twitter date format: "Wed Oct 15 06:04:00 +0000 2025"
        const parseTwitterDate = (dateStr) => {
          if (!dateStr) return null;
          const date = new Date(dateStr);
          const timestamp = Math.floor(date.getTime() / 1000);
          // Debug: log if parsing failed
          if (isNaN(timestamp)) {
            console.warn('Failed to parse Twitter date:', dateStr);
            return null;
          }
          return timestamp;
        };
        
        // Extract mentions and hashtags
        const mentions = (tweetLegacy.entities?.user_mentions || []).map(m => ({
          type: 0,
          userUniqueId: m.screen_name,
          userId: m.id_str
        }));
        
        const hashtags = (tweetLegacy.entities?.hashtags || []).map(h => ({
          id: h.text,
          title: h.text
        }));
        
        if (mentions.length > 0 || hashtags.length > 0) {
          console.log(`Tweet ${tweet.rest_id}: ${mentions.length} mentions, ${hashtags.length} hashtags`);
        }
        
        normalized.data = {
          // Post ID
          id: tweet.rest_id,
          // Author info
          author: {
            id: userResult.rest_id,
            uniqueId: userCore.screen_name || '',
            nickname: userCore.name || '',
            verified: userResult.is_blue_verified || userResult.verification?.verified || false,
            createTime: parseTwitterDate(userCore.created_at) // Account creation date
          },
          // Timestamp
          createTime: parseTwitterDate(tweetLegacy.created_at),
          // Tweet text
          desc: tweetLegacy.full_text || '',
          // Hashtags
          challenges: hashtags,
          // Mentions
          textExtra: mentions,
          // Engagement stats
          stats: {
            diggCount: tweetLegacy.favorite_count || 0,
            commentCount: tweetLegacy.reply_count || 0,
            shareCount: tweetLegacy.retweet_count || 0,
            playCount: parseInt(tweet.views?.count || '0')
          },
          // Author stats
          authorStats: {
            followerCount: userLegacy.followers_count || 0,
            followingCount: userLegacy.friends_count || 0,
            heartCount: userLegacy.favourites_count || 0,
            videoCount: userLegacy.statuses_count || 0
          }
        };
      }

      return normalized;
    }

    // Normalize all raw data on load
    function normalizeRawData(data) {
      return data.map(post => normalizePost(post));
    }

    // =========================
    // DOM elements
    // =========================
    const fileInput = document.getElementById('file-input');
    const networkTypeSelect = document.getElementById('network-type');
    const nodeSizeBySelect = document.getElementById('node-size-by');
    const engagementFilter = document.getElementById('engagement-filter');
    const engagementValue = document.getElementById('engagement-value');
    const cibThreshold = document.getElementById('cib-threshold');
    const thresholdValue = document.getElementById('threshold-value');
    const timeWindowInput = document.getElementById('time-window');
    const timeWindowValue = document.getElementById('time-window-value');
    const dateStart = document.getElementById('date-start');
    const dateEnd = document.getElementById('date-end');
    const searchInput = document.getElementById('search-input');
    const exportBtn = document.getElementById('export-btn');
    const detectBtn = document.getElementById('detect-btn');
    const cibBtn = document.getElementById('cib-btn');
    const cibSettingsBtn = document.getElementById('cib-settings-btn');
    const cibSettingsPanel = document.getElementById('cib-settings-panel');
    const closeCibSettings = document.getElementById('close-cib-settings');
    const resetCibParamsBtn = document.getElementById('reset-cib-params');
    const canvas = document.getElementById('network-canvas');
    let ctx = null; // Don't create context yet - let renderer decide
    let gl = null;
    let gpuRenderer = null;
    const emptyState = document.getElementById('empty-state');
    const statsDiv = document.getElementById('stats');
    const nodeInfo = document.getElementById('node-info');
    const nodeDetails = document.getElementById('node-details');
    const closeInfo = document.getElementById('close-info');
    const loading = document.getElementById('loading');
    const loadingText = document.getElementById('loading-text');
    const metricsPanel = document.getElementById('metrics-panel');
    const metricsList = document.getElementById('metrics-list');
    const cibPanel = document.getElementById('cib-panel');
    const cibResults = document.getElementById('cib-results');
    const tooltipEl = document.getElementById('node-tooltip');
    const modalEl   = document.getElementById('node-modal');
    const modalClose= document.getElementById('modal-close');
    const modalTitle= document.getElementById('modal-title');
    const modalBody = document.getElementById('modal-body');
    const platformIndicator = document.getElementById('platform-indicator');
    const renderingIndicator = document.getElementById('rendering-indicator');

    // =========================
    // UI constants
    // =========================
    const communityColors = ['#ef4444','#f59e0b','#10b981','#3b82f6','#8b5cf6','#ec4899','#14b8a6','#f97316','#06b6d4','#84cc16'];
    const thresholdLabels = {
      1:'Very Low (1)',2:'Low (2)',3:'Low-Med (3)',4:'Medium-Low (4)',5:'Medium (5)',
      6:'Medium-High (6)',7:'High-Med (7)',8:'High (8)',9:'Very High (9)',10:'Maximum (10)'
    };

    cibThreshold.addEventListener('input', (e)=>{ thresholdValue.textContent = thresholdLabels[e.target.value]; });

    timeWindowInput.addEventListener('input', (e) => {
      const seconds = parseInt(e.target.value);
      if (seconds < 60) {
        timeWindowValue.textContent = `${seconds} second${seconds !== 1 ? 's' : ''}`;
      } else {
        const minutes = Math.floor(seconds / 60);
        const remainingSecs = seconds % 60;
        if (remainingSecs === 0) {
          timeWindowValue.textContent = `${minutes} minute${minutes !== 1 ? 's' : ''}`;
        } else {
          timeWindowValue.textContent = `${minutes}m ${remainingSecs}s`;
        }
      }
    });

    // =========================
    // File upload
    // =========================
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (!file) return;

      loading.classList.add('active');
      loadingText.textContent = 'Loading data...';

      try {
        const text = await file.text();
        const lines = text.trim().split('\n');
        const parsed = lines.map(line => JSON.parse(line));
        
        // Normalize data to handle both TikTok and Instagram
        rawData = normalizeRawData(parsed);

        // Detect platforms
        const platformCounts = {};
        rawData.forEach(p => {
          const platform = p.platform || 'unknown';
          platformCounts[platform] = (platformCounts[platform] || 0) + 1;
        });
        
        const platformParts = [];
        if (platformCounts.tiktok) platformParts.push(`🎵 TikTok (${platformCounts.tiktok})`);
        if (platformCounts.instagram) platformParts.push(`📷 Instagram (${platformCounts.instagram})`);
        if (platformCounts.twitter) platformParts.push(`🐦 Twitter/X (${platformCounts.twitter})`);
        if (platformCounts.unknown) platformParts.push(`❓ Unknown (${platformCounts.unknown})`);
        
        const platformText = platformParts.join(' · ') || 'No data';
        platformIndicator.textContent = `· ${platformText}`;
        console.log(`Loaded ${rawData.length} posts from: ${platformText}`);

        // set date bounds from data (both platforms use createTime after normalization)
        const dates = rawData.map(p => p.data?.createTime).filter(Boolean);
        if (dates.length > 0) {
          const minDate = new Date(Math.min(...dates) * 1000);
          const maxDate = new Date(Math.max(...dates) * 1000);
          dateStart.value = minDate.toISOString().split('T')[0];
          dateEnd.value = maxDate.toISOString().split('T')[0];
        }

        calculateStats();
        updateNetwork();
        emptyState.style.display = 'none';
        statsDiv.style.display = 'grid';
        exportBtn.disabled = false;
        detectBtn.disabled = false;
        cibBtn.disabled = false;
        cibSettingsBtn.disabled = false;
      } catch (err) {
        alert('Error parsing file: ' + err.message);
      } finally {
        loading.classList.remove('active');
      }
    });

    // =========================
    // Stats
    // =========================
    function calculateStats() {
      const uniqueUsers = new Set(rawData.map(p => p.data?.author?.id).filter(Boolean));
      const allHashtags = rawData.flatMap(p => p.data?.challenges?.map(c => c.title) || []);
      const uniqueHashtags = new Set(allHashtags);

      const totalEngagement = rawData.reduce((sum, p) => {
        return sum + (p.data?.stats?.diggCount || 0) + (p.data?.stats?.commentCount || 0);
      }, 0);

      document.getElementById('stat-posts').textContent = rawData.length;
      document.getElementById('stat-users').textContent = uniqueUsers.size;
      document.getElementById('stat-hashtags').textContent = uniqueHashtags.size;
      document.getElementById('stat-engagement').textContent = rawData.length ? Math.round(totalEngagement / rawData.length) : 0;
    }

    // =========================
    // Filters (engagement + date)
    // =========================
    function filterData() {
      const minEngagement = parseInt(engagementFilter.value, 10);
      const startDate = dateStart.value ? new Date(dateStart.value).getTime() / 1000 : 0;
      // Add 86399 seconds (23:59:59) to make end date inclusive of the entire day
      const endDate = dateEnd.value ? (new Date(dateEnd.value).getTime() / 1000) + 86399 : Infinity;

      let debugCount = 0;
      filteredData = rawData.filter(post => {
        const engagement = (post.data?.stats?.diggCount || 0) + (post.data?.stats?.commentCount || 0) + (post.data?.stats?.shareCount || 0);
        const postTime = post.data?.createTime;
        
        // Include posts with missing timestamps if no date filter is set
        const passesDateFilter = !postTime ? (!dateStart.value && !dateEnd.value) : 
                                  (postTime >= startDate && postTime <= endDate);
        
        const passesEngagement = engagement >= minEngagement;
        
        // Debug first few failed filters
        if (debugCount < 3 && (!passesEngagement || !passesDateFilter)) {
          console.log(`Filter Debug - Post ${post.item_id}:`, {
            engagement,
            minEngagement,
            passesEngagement,
            postTime,
            hasDateStart: !!dateStart.value,
            hasDateEnd: !!dateEnd.value,
            passesDateFilter,
            createTime: post.data?.createTime
          });
          debugCount++;
        }
        
        return passesEngagement && passesDateFilter;
      });

      console.log(`Filtered: ${filteredData.length} posts out of ${rawData.length} (${rawData.length - filteredData.length} filtered out). MinEngagement: ${minEngagement}, DateRange: ${dateStart.value || 'none'} - ${dateEnd.value || 'none'}`);
      return filteredData;
    }

    // =========================
    // CIB Advanced Parameters
    // =========================
    
    // Default parameter values
    const defaultCibParams = {
      semanticEnabled: true,
      semanticThreshold: 0.85,
      ngramThreshold: 0.3,
      usernameThreshold: 0.8,
      tfidfThreshold: 0.5,
      zscoreThreshold: 2,
      burstPosts: 5,
      rhythmCV: 0.1,
      nightGap: 7200,
      clusterSize: 5,
      crossMultiplier: 0.3
    };
    
    // Get current parameter values from UI (or defaults if panel not visible)
    function getCibParams() {
      return {
        semanticEnabled: document.getElementById('param-semantic-enabled')?.value === 'true',
        semanticThreshold: parseFloat(document.getElementById('param-semantic-threshold')?.value || defaultCibParams.semanticThreshold),
        ngramThreshold: parseFloat(document.getElementById('param-ngram-threshold')?.value || defaultCibParams.ngramThreshold),
        usernameThreshold: parseFloat(document.getElementById('param-username-threshold')?.value || defaultCibParams.usernameThreshold),
        tfidfThreshold: parseFloat(document.getElementById('param-tfidf-threshold')?.value || defaultCibParams.tfidfThreshold),
        zscoreThreshold: parseFloat(document.getElementById('param-zscore-threshold')?.value || defaultCibParams.zscoreThreshold),
        burstPosts: parseInt(document.getElementById('param-burst-posts')?.value || defaultCibParams.burstPosts),
        rhythmCV: parseFloat(document.getElementById('param-rhythm-cv')?.value || defaultCibParams.rhythmCV),
        nightGap: parseInt(document.getElementById('param-night-gap')?.value || defaultCibParams.nightGap),
        clusterSize: parseInt(document.getElementById('param-cluster-size')?.value || defaultCibParams.clusterSize),
        crossMultiplier: parseFloat(document.getElementById('param-cross-multiplier')?.value || defaultCibParams.crossMultiplier)
      };
    }
    
    // Reset parameters to defaults
    function resetCibParams() {
      document.getElementById('param-semantic-enabled').value = defaultCibParams.semanticEnabled.toString();
      document.getElementById('param-semantic-threshold').value = defaultCibParams.semanticThreshold;
      document.getElementById('param-ngram-threshold').value = defaultCibParams.ngramThreshold;
      document.getElementById('param-username-threshold').value = defaultCibParams.usernameThreshold;
      document.getElementById('param-tfidf-threshold').value = defaultCibParams.tfidfThreshold;
      document.getElementById('param-zscore-threshold').value = defaultCibParams.zscoreThreshold;
      document.getElementById('param-burst-posts').value = defaultCibParams.burstPosts;
      document.getElementById('param-rhythm-cv').value = defaultCibParams.rhythmCV;
      document.getElementById('param-night-gap').value = defaultCibParams.nightGap;
      document.getElementById('param-cluster-size').value = defaultCibParams.clusterSize;
      document.getElementById('param-cross-multiplier').value = defaultCibParams.crossMultiplier;
    }

    // =========================
    // CIB Helper Functions
    // =========================
    
    // Statistical Z-Score calculation for adaptive thresholds
    function calculateDatasetStatistics() {
      const postCounts = new Map();
      const hashtagCounts = new Map();
      
      filteredData.forEach(post => {
        const userId = post.data?.author?.id;
        if (!userId) return;
        
        postCounts.set(userId, (postCounts.get(userId) || 0) + 1);
        
        const hashtags = post.data?.challenges?.length || 0;
        hashtagCounts.set(userId, (hashtagCounts.get(userId) || 0) + hashtags);
      });
      
      const posts = Array.from(postCounts.values());
      const hashtags = Array.from(hashtagCounts.values());
      
      // Calculate mean once and reuse for stdDev calculation (optimization)
      const postsMean = posts.reduce((a, b) => a + b, 0) / posts.length;
      const hashtagsMean = hashtags.reduce((a, b) => a + b, 0) / hashtags.length;
      
      return {
        posts: {
          mean: postsMean,
          stdDev: Math.sqrt(posts.reduce((sq, n) => sq + Math.pow(n - postsMean, 2), 0) / posts.length)
        },
        hashtags: {
          mean: hashtagsMean,
          stdDev: Math.sqrt(hashtags.reduce((sq, n) => sq + Math.pow(n - hashtagsMean, 2), 0) / hashtags.length)
        }
      };
    }
    
    // TF-IDF weighting for hashtag importance
    function calculateTFIDF(hashtag, userHashtags, allHashtags) {
      // Term Frequency: count occurrences without creating new array (optimization)
      let count = 0;
      for (let i = 0; i < userHashtags.length; i++) {
        if (userHashtags[i] === hashtag) count++;
      }
      const tf = count / userHashtags.length;
      
      // Inverse Document Frequency: count without filter (optimization)
      let usersWithHashtag = 0;
      for (let i = 0; i < allHashtags.length; i++) {
        if (allHashtags[i].has(hashtag)) usersWithHashtag++;
      }
      const idf = Math.log(allHashtags.length / (usersWithHashtag + 1));
      
      return tf * idf;
    }
    
    // N-gram extraction for caption templates
    function getNGrams(text, n = 5) {
      const words = text.toLowerCase().replace(/[^\w\s]/g, '').split(/\s+/);
      const ngrams = [];
      
      for (let i = 0; i <= words.length - n; i++) {
        ngrams.push(words.slice(i, i + n).join(' '));
      }
      
      return new Set(ngrams);
    }
    
    // N-gram overlap calculation (Jaccard similarity)
    function ngramOverlap(text1, text2, n = 5) {
      const ngrams1 = getNGrams(text1, n);
      const ngrams2 = getNGrams(text2, n);
      
      if (ngrams1.size === 0 || ngrams2.size === 0) return 0;
      
      const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
      const union = new Set([...ngrams1, ...ngrams2]);
      
      return intersection.size / union.size;
    }
    
    // Levenshtein distance for username similarity
    function levenshteinDistance(str1, str2) {
      const matrix = [];
      
      for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
      }
      
      for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
      }
      
      for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
          if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
            matrix[i][j] = matrix[i - 1][j - 1];
          } else {
            matrix[i][j] = Math.min(
              matrix[i - 1][j - 1] + 1,
              matrix[i][j - 1] + 1,
              matrix[i - 1][j] + 1
            );
          }
        }
      }
      
      return matrix[str2.length][str1.length];
    }
    
    // Temporal burst detection
    function detectTemporalBursts(postsByUser, timeWindow, minPosts = 5) {
      const bursts = [];
      
      postsByUser.forEach((posts, userId) => {
        const timestamps = posts.map(p => p.timestamp).sort((a, b) => a - b);
        
        // Find bursts: minPosts+ within timeWindow (optimized counting)
        for (let i = 0; i < timestamps.length; i++) {
          const windowEnd = timestamps[i] + timeWindow;
          
          // Count posts in window without creating new array (optimization)
          let postsInWindow = 0;
          let j = i;
          while (j < timestamps.length && timestamps[j] < windowEnd) {
            postsInWindow++;
            j++;
          }
          
          if (postsInWindow >= minPosts) {
            bursts.push({ 
              userId, 
              time: timestamps[i], 
              count: postsInWindow,
              timestamps: timestamps.slice(i, j)
            });
            break; // Only count first burst per user
          }
        }
      });
      
      return bursts;
    }
    
    // Posting rhythm regularity analysis
    function analyzePostingRhythm(posts, cvThreshold = 0.1) {
      if (posts.length < 5) return { regular: false, stdDev: null };
      
      const timestamps = posts.map(p => p.timestamp).sort();
      const intervals = [];
      
      for (let i = 1; i < timestamps.length; i++) {
        intervals.push(timestamps[i] - timestamps[i-1]);
      }
      
      const mean = intervals.reduce((a, b) => a + b) / intervals.length;
      const variance = intervals.reduce((sum, interval) => {
        return sum + Math.pow(interval - mean, 2);
      }, 0) / intervals.length;
      const stdDev = Math.sqrt(variance);
      
      // Very regular if stdDev < cvThreshold% of mean (coefficient of variation)
      const coefficientOfVariation = stdDev / mean;
      
      return {
        regular: coefficientOfVariation < cvThreshold,
        stdDev: stdDev,
        mean: mean,
        cv: coefficientOfVariation
      };
    }
    
    // Night posting analysis (24/7 activity detection)
    function analyzeNightPosting(posts, gapThreshold = 7200) {
      if (posts.length < 10) return { suspicious: false };
      
      const timestamps = posts.map(p => p.timestamp).sort();
      const dailyGaps = new Map();
      
      // Group by day and find longest gap
      timestamps.forEach(ts => {
        const date = new Date(ts * 1000);
        const dayKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
        
        if (!dailyGaps.has(dayKey)) dailyGaps.set(dayKey, []);
        dailyGaps.get(dayKey).push(date.getHours() * 3600 + date.getMinutes() * 60);
      });
      
      const avgMaxGap = Array.from(dailyGaps.values()).map(day => {
        day.sort((a, b) => a - b);
        let maxGap = 0;
        
        for (let i = 1; i < day.length; i++) {
          maxGap = Math.max(maxGap, day[i] - day[i-1]);
        }
        
        // Check wrap-around (end of day to start)
        if (day.length > 1) {
          maxGap = Math.max(maxGap, 86400 - day[day.length-1] + day[0]);
        }
        
        return maxGap;
      }).reduce((a, b) => a + b, 0) / dailyGaps.size;
      
      // Flag if average longest gap < threshold (default: 2 hours = 7200 seconds)
      return {
        suspicious: avgMaxGap < gapThreshold,
        avgMaxGap: avgMaxGap
      };
    }
    
    // Account creation clustering
    function detectAccountCreationClusters(posts, timeWindow = 86400, minClusterSize = 5) { // 24 hours
      const accountCreationTimes = new Map();
      
      posts.forEach(post => {
        const author = post.data?.author;
        if (!author?.id) return;
        
        // For TikTok, check if account creation time is available
        const creationTime = author.createTime || post.data?.createTime;
        if (!creationTime) return;
        
        accountCreationTimes.set(author.id, creationTime);
      });
      
      // Group accounts by creation time
      const clusters = new Map();
      const sorted = Array.from(accountCreationTimes.entries()).sort((a, b) => a[1] - b[1]);
      
      sorted.forEach(([userId, time]) => {
        let foundCluster = false;
        
        for (const [clusterTime, accounts] of clusters) {
          if (Math.abs(time - clusterTime) < timeWindow) {
            accounts.add(userId);
            foundCluster = true;
            break;
          }
        }
        
        if (!foundCluster) {
          clusters.set(time, new Set([userId]));
        }
      });
      
      return Array.from(clusters.values()).filter(cluster => cluster.size >= minClusterSize);
    }

    // =========================
    // CIB detection (heuristics)
    // =========================
    async function detectCIB() {
      loading.classList.add('active');
      loadingText.textContent = 'Analyzing coordinated behavior patterns...';

      setTimeout(async () => {
        const threshold = parseInt(cibThreshold.value, 10);
        const sensitivity = 11 - threshold; // higher threshold = stricter

        const results = { suspiciousUsers: new Set(), indicators: {} };
        
        // Get advanced parameters (uses defaults if settings panel not customized)
        const params = getCibParams();
        
        // Initialize embedding model only if semantic similarity is enabled
        if (params.semanticEnabled) {
          await initEmbeddingModel();
        }
        
        // Calculate dataset statistics for adaptive thresholds
        const stats = calculateDatasetStatistics();

        // 1) Synchronized posting
        const postsByUser = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const timestamp = post.data?.createTime;
          if (!userId || !timestamp) return;
          if (!postsByUser.has(userId)) postsByUser.set(userId, []);
          postsByUser.get(userId).push({ timestamp, post });
        });
        const timeWindow = parseInt(timeWindowInput.value, 10);
        const synchGroups = [];
        const userTs = Array.from(postsByUser.entries());
        for (let i=0;i<userTs.length;i++){
          for (let j=i+1;j<userTs.length;j++){
            const [u1, p1] = userTs[i]; const [u2, p2] = userTs[j];
            let syncCount = 0;
            p1.forEach(a => p2.forEach(b => { if (Math.abs(a.timestamp - b.timestamp) < timeWindow) syncCount++; }));
            if (syncCount >= Math.max(2, Math.floor(10/sensitivity))) {
              results.suspiciousUsers.add(u1); results.suspiciousUsers.add(u2); synchGroups.push({ u1, u2, syncCount });
            }
          }
        }
        results.indicators.synchronized = synchGroups.length;

        // 2) Rare hashtag sequences with TF-IDF weighting
        // Build hashtag usage map first
        const userHashtagSets = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const hashtags = post.data?.challenges?.map(c => c.title) || [];
          if (!userId || !hashtags.length) return;
          
          if (!userHashtagSets.has(userId)) userHashtagSets.set(userId, []);
          hashtags.forEach(h => userHashtagSets.get(userId).push(h));
        });

        // Detect with TF-IDF weighting to find rare coordinated hashtag combinations
        const hashtagSequences = new Map();
        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const hashtags = post.data?.challenges?.map(c => c.title) || [];
          if (!userId || !hashtags.length) return;
          
          // Calculate TF-IDF score for this hashtag set
          const allSets = Array.from(userHashtagSets.values()).map(arr => new Set(arr));
          const tfidfScore = hashtags.reduce((sum, h) => {
            return sum + calculateTFIDF(h, userHashtagSets.get(userId), allSets);
          }, 0) / hashtags.length;
          
          // Only consider high TF-IDF sequences (rare combinations)
          if (tfidfScore > params.tfidfThreshold) {
            const key = hashtags.sort().join(',');
            if (!hashtagSequences.has(key)) hashtagSequences.set(key, { users: new Set(), tfidf: tfidfScore });
            hashtagSequences.get(key).users.add(userId);
          }
        });

        // Flag groups using rare hashtag combinations
        let identicalHashtagUsers = 0;
        hashtagSequences.forEach((data, key) => {
          if (data.users.size >= Math.max(3, Math.floor(15/sensitivity))) {
            data.users.forEach(u => results.suspiciousUsers.add(u));
            identicalHashtagUsers += data.users.size;
          }
        });
        results.indicators.identicalHashtags = identicalHashtagUsers;

        // 3) Similar usernames with Levenshtein distance
        const usernames = new Map();
        filteredData.forEach(post => {
          const author = post.data?.author;
          if (!author) return;
          const username = author.uniqueId || author.nickname || '';
          const userId = author.id;
          if (username.length < 4) return;
          
          usernames.set(userId, username);
        });

        const usernameGroups = new Map();
        const usernameArray = Array.from(usernames.entries());

        for (let i = 0; i < usernameArray.length; i++) {
          for (let j = i + 1; j < usernameArray.length; j++) {
            const [id1, name1] = usernameArray[i];
            const [id2, name2] = usernameArray[j];
            
            const distance = levenshteinDistance(name1, name2);
            const maxLen = Math.max(name1.length, name2.length);
            const similarity = 1 - (distance / maxLen);
            
            // Check against threshold (default 80%+ similar)
            if (similarity >= params.usernameThreshold) {
              const key = [name1, name2].sort().join('|');
              if (!usernameGroups.has(key)) usernameGroups.set(key, new Set());
              usernameGroups.get(key).add(id1);
              usernameGroups.get(key).add(id2);
            }
          }
        }

        let similarUsernameCount = 0;
        usernameGroups.forEach((users, key) => {
          if (users.size >= Math.max(3, Math.floor(12/sensitivity))) {
            users.forEach(u => results.suspiciousUsers.add(u));
            similarUsernameCount += users.size;
          }
        });
        results.indicators.similarUsernames = similarUsernameCount;

        // 4) High-volume posting with z-score normalization
        const minPosts = Math.max(5, Math.floor(25/sensitivity));
        results.indicators.highVolume = 0;
        postsByUser.forEach((posts, userId) => {
          if (posts.length >= minPosts) {
            const zScore = (posts.length - stats.posts.mean) / stats.posts.stdDev;
            
            // Flag if z-score exceeds threshold (default: 2 = 95th percentile)
            if (zScore > params.zscoreThreshold) {
              results.suspiciousUsers.add(userId);
              results.indicators.highVolume++;
            }
          }
        });
        
        // 5) Temporal burst detection
        const bursts = detectTemporalBursts(postsByUser, timeWindow, params.burstPosts);
        results.indicators.temporalBursts = bursts.length;
        
        // 6) Posting rhythm regularity & 24/7 activity
        postsByUser.forEach((posts, userId) => {
          // Check posting rhythm regularity
          const rhythm = analyzePostingRhythm(posts, params.rhythmCV);
          if (rhythm.regular) {
            results.suspiciousUsers.add(userId);
          }
          
          // Check 24/7 posting pattern
          const nightPosting = analyzeNightPosting(posts, params.nightGap);
          if (nightPosting.suspicious) {
            results.suspiciousUsers.add(userId);
          }
        });

        // 7) Semantic duplicate captions (AI-powered similarity)
        let semanticGroups = [];
        
        if (params.semanticEnabled) {
          // Only run if enabled (can be slow on large datasets)
          const captionEmbeddings = new Map();
          
          for (const post of filteredData) {
            const userId = post.data?.author?.id;
            const caption = post.data?.desc || '';
            if (!userId || caption.length < 20) continue;
            
            const embedding = await getEmbedding(caption);
            captionEmbeddings.set(userId, { caption, embedding, userId });
          }
          
          // Compare all pairs for semantic similarity
          const embedArray = Array.from(captionEmbeddings.values());
          for (let i = 0; i < embedArray.length; i++) {
            for (let j = i + 1; j < embedArray.length; j++) {
              const similarity = cosineSimilarity(embedArray[i].embedding, embedArray[j].embedding);
              
              // Check against threshold (default: 0.85 = very similar, paraphrased content)
              if (similarity >= params.semanticThreshold) {
                results.suspiciousUsers.add(embedArray[i].userId);
                results.suspiciousUsers.add(embedArray[j].userId);
                semanticGroups.push({ 
                  users: [embedArray[i].userId, embedArray[j].userId],
                  similarity: similarity.toFixed(3),
                  captions: [embedArray[i].caption.slice(0, 50), embedArray[j].caption.slice(0, 50)]
                });
              }
            }
          }
        }
        
        results.indicators.semanticDuplicates = semanticGroups.length;
        
        // 8) N-gram template captions
        const captionPairs = [];
        const captions = new Map();

        filteredData.forEach(post => {
          const userId = post.data?.author?.id;
          const caption = post.data?.desc || '';
          if (!userId || caption.length < 20) return;
          
          captions.set(userId, caption);
        });

        const captionArray = Array.from(captions.entries());
        for (let i = 0; i < captionArray.length; i++) {
          for (let j = i + 1; j < captionArray.length; j++) {
            const overlap = ngramOverlap(captionArray[i][1], captionArray[j][1]);
            
            // Check against threshold (default: 0.3 = 30% of 5-grams match, template detected)
            if (overlap >= params.ngramThreshold) {
              captionPairs.push({
                users: [captionArray[i][0], captionArray[j][0]],
                overlap: overlap
              });
              results.suspiciousUsers.add(captionArray[i][0]);
              results.suspiciousUsers.add(captionArray[j][0]);
            }
          }
        }

        results.indicators.templateCaptions = captionPairs.length;
        results.indicators.duplicateCaptions = semanticGroups.length + captionPairs.length;
        
        // 9) Account creation clustering
        const creationClusters = detectAccountCreationClusters(filteredData, 86400, params.clusterSize);
        results.indicators.accountCreationClusters = creationClusters.length;

        // Build userId -> username lookup
        const userIdToName = new Map();
        filteredData.forEach(post => {
          const author = post.data?.author;
          if (author?.id) {
            userIdToName.set(author.id, author.uniqueId || author.nickname || `user_${author.id}`);
          }
        });
        
        // risk scores and reasons
        results.userScores = new Map();
        results.userReasons = new Map();
        results.suspiciousUsers.forEach(userId => {
          let score = 0;
          let reasons = [];
          
          // Check synchronized posting
          const userSyncGroups = synchGroups.filter(g => g.u1===userId || g.u2===userId);
          if (userSyncGroups.length > 0) {
            score += 25;
            const partners = userSyncGroups.map(g => {
              const partnerId = g.u1 === userId ? g.u2 : g.u1;
              return userIdToName.get(partnerId) || partnerId;
            }).slice(0, 5);
            const more = userSyncGroups.length > 5 ? ` and ${userSyncGroups.length - 5} more` : '';
            reasons.push(`Synchronized posting with: ${partners.join(', ')}${more}`);
          }
          
          // Check rare hashtag sequences (TF-IDF weighted)
          const userPosts = filteredData.filter(p => p.data?.author?.id === userId);
          const hashtagPartners = [];
          hashtagSequences.forEach((data, seq) => {
            if (data.users.has(userId) && data.users.size >= Math.max(3, Math.floor(15/sensitivity))) {
              const others = Array.from(data.users).filter(u => u !== userId).map(u => userIdToName.get(u) || u);
              hashtagPartners.push(...others);
            }
          });
          if (hashtagPartners.length > 0) {
            score += 20;
            const display = hashtagPartners.slice(0, 5);
            const more = hashtagPartners.length > 5 ? ` and ${hashtagPartners.length - 5} more` : '';
            reasons.push(`Rare hashtag combinations with: ${display.join(', ')}${more}`);
          }
          
          // Check similar username (Levenshtein distance)
          usernameGroups.forEach((users, key) => {
            if (users.has(userId) && users.size >= Math.max(3, Math.floor(12/sensitivity))) {
              score += 10;
              const similarUsers = Array.from(users).filter(u => u !== userId).map(u => userIdToName.get(u) || u);
              const display = similarUsers.slice(0, 5);
              const more = similarUsers.length > 5 ? ` and ${similarUsers.length - 5} more` : '';
              reasons.push(`Similar username pattern with: ${display.join(', ')}${more}`);
            }
          });
          
          // Check high-volume posting (z-score)
          if (userPosts.length >= minPosts) {
            const zScore = (userPosts.length - stats.posts.mean) / stats.posts.stdDev;
            if (zScore > 2) {
              score += 15;
              reasons.push(`High-volume posting (z-score: ${zScore.toFixed(1)})`);
            }
          }
          
          // Check temporal bursts
          const userBursts = bursts.filter(b => b.userId === userId);
          if (userBursts.length > 0) {
            score += 15;
            userBursts.forEach(burst => {
              const timeDesc = timeWindow < 60 ? `${timeWindow} second${timeWindow !== 1 ? 's' : ''}` : 
                               `${Math.floor(timeWindow/60)} minute${Math.floor(timeWindow/60) !== 1 ? 's' : ''}`;
              reasons.push(`Posting burst: ${burst.count} posts in ${timeDesc}`);
            });
          }
          
          // Check posting rhythm regularity
          const rhythm = analyzePostingRhythm(userPosts.map(p => ({ timestamp: p.data?.createTime })).filter(p => p.timestamp), params.rhythmCV);
          if (rhythm.regular) {
            score += 20;
            reasons.push(`Highly regular posting rhythm (CV: ${(rhythm.cv * 100).toFixed(1)}%)`);
          }
          
          // Check 24/7 posting
          const nightPosting = analyzeNightPosting(userPosts.map(p => ({ timestamp: p.data?.createTime })).filter(p => p.timestamp), params.nightGap);
          if (nightPosting.suspicious) {
            score += 25;
            reasons.push(`24/7 posting pattern (max gap: ${Math.floor(nightPosting.avgMaxGap / 3600)}h)`);
          }
          
          // Check semantic duplicate captions
          semanticGroups.forEach(group => {
            if (group.users.includes(userId)) {
              score += 25;
              const partner = group.users.find(u => u !== userId);
              const partnerName = userIdToName.get(partner) || partner;
              reasons.push(`Semantically similar captions (${group.similarity}) with ${partnerName}`);
            }
          });
          
          // Check n-gram template captions
          captionPairs.forEach(pair => {
            if (pair.users.includes(userId)) {
              score += 20;
              const partner = pair.users.find(u => u !== userId);
              const partnerName = userIdToName.get(partner) || partner;
              reasons.push(`Template caption (${(pair.overlap * 100).toFixed(0)}% overlap) with ${partnerName}`);
            }
          });
          
          // Check account creation clusters
          creationClusters.forEach(cluster => {
            if (cluster.has(userId)) {
              score += 30;
              reasons.push(`Account created with ${cluster.size - 1} others within 24 hours`);
            }
          });
          
          results.userScores.set(userId, score);
          results.userReasons.set(userId, reasons);
        });
        
        // Cross-indicator bonus multiplier (multiple indicators = exponentially more suspicious)
        results.suspiciousUsers.forEach(userId => {
          const reasons = results.userReasons.get(userId) || [];
          const numIndicators = reasons.length;
          let baseScore = results.userScores.get(userId) || 0;
          
          // Multiplicative bonus for multiple indicators
          if (numIndicators >= 2) {
            const multiplier = 1 + (params.crossMultiplier * numIndicators);
            baseScore = Math.min(100, baseScore * multiplier);
            results.userScores.set(userId, Math.round(baseScore));
          }
          
          // Extra bonus for specific dangerous combinations
          const reasonText = reasons.join(' ').toLowerCase();
          
          if (reasonText.includes('similar username') && reasonText.includes('created with')) {
            // Username similarity + account creation = bot farm
            const currentScore = results.userScores.get(userId);
            results.userScores.set(userId, Math.min(100, currentScore + 20));
          }
          
          if (reasonText.includes('synchronized') && reasonText.includes('regular posting')) {
            // Synchronization + regularity = automated coordination
            const currentScore = results.userScores.get(userId);
            results.userScores.set(userId, Math.min(100, currentScore + 15));
          }
        });

        cibDetection = results;
        displayCIBResults(results);

        // mark nodes
        if (nodes.length > 0) {
          nodes.forEach(node => {
            const plainId = node.id.replace(/^u_/,'');
            if (results.suspiciousUsers.has(node.id) || results.suspiciousUsers.has(plainId)) {
              node.suspicious = true;
              node.cibScore = results.userScores.get(node.id) || results.userScores.get(plainId) || 0;
              node.cibReasons = results.userReasons.get(node.id) || results.userReasons.get(plainId) || [];
            }
          });
          drawNetwork();
        }
        document.getElementById('stat-suspicious').textContent = results.suspiciousUsers.size;

        loading.classList.remove('active');
        updateCoach();
      }, 100);
    }

    function displayCIBResults(results) {
      const params = getCibParams(); // Check if semantic is enabled
      
      let html = '<ul class="metrics-list">';
      html += `<li><span class="metric-name">Suspicious Accounts</span><span class="metric-value cib-score">${results.suspiciousUsers.size}</span></li>`;
      html += `<li><span class="metric-name">Synchronized Posting</span><span class="metric-value">${results.indicators.synchronized} pairs</span></li>`;
      html += `<li><span class="metric-name">Rare Hashtag Combos</span><span class="metric-value">${results.indicators.identicalHashtags} users</span></li>`;
      html += `<li><span class="metric-name">Similar Usernames</span><span class="metric-value">${results.indicators.similarUsernames} users</span></li>`;
      html += `<li><span class="metric-name">High Volume Posting</span><span class="metric-value">${results.indicators.highVolume} users</span></li>`;
      
      // New AI-powered indicators
      if (results.indicators.semanticDuplicates > 0) {
        html += `<li><span class="metric-name">🤖 Semantic Duplicates</span><span class="metric-value">${results.indicators.semanticDuplicates} pairs</span></li>`;
      } else if (!params.semanticEnabled) {
        html += `<li><span class="metric-name">🤖 Semantic Duplicates</span><span class="metric-value" style="color: #9ca3af;">disabled</span></li>`;
      }
      
      if (results.indicators.temporalBursts) {
        html += `<li><span class="metric-name">Posting Bursts</span><span class="metric-value">${results.indicators.temporalBursts} users</span></li>`;
      }
      if (results.indicators.templateCaptions) {
        html += `<li><span class="metric-name">Template Captions</span><span class="metric-value">${results.indicators.templateCaptions} pairs</span></li>`;
      }
      if (results.indicators.accountCreationClusters) {
        html += `<li><span class="metric-name">Account Creation Clusters</span><span class="metric-value">${results.indicators.accountCreationClusters} clusters</span></li>`;
      }
      
      html += '</ul>';
      cibResults.innerHTML = html;
      cibPanel.style.display = 'block';
    }

    // =========================
    // Network extraction
    // =========================
    function extractMentionNetwork(posts) {
      const nodeMap = new Map();
      const links = [];
      
      let debugCount = 0;

      posts.forEach(post => {
        const author = post.data?.author;
        if (!author) {
          console.log('Post missing author:', post.item_id);
          return;
        }

        const authorId = author.id;
        if (!authorId) {
          console.log('Author missing ID:', author);
          return;
        }
        
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            verified: author.verified,
            followers: post.data?.authorStats?.followerCount || 0,
            type: 'user'
          });
        }
        const mentions = post.data?.textExtra?.filter(t => t.type === 0) || [];
        
        // Debug first few posts
        if (debugCount < 3 && mentions.length > 0) {
          console.log(`Post ${post.item_id}: authorId=${authorId}, ${mentions.length} mentions`, mentions.map(m => `${m.userUniqueId}(${m.userId})`));
          debugCount++;
        }
        
        mentions.forEach(mention => {
          // Use userId if available, otherwise create ID from username
          const mentionId = mention.userId || `user_${mention.userUniqueId}`;
          if (!mentionId || mentionId === 'user_undefined') return; // Skip invalid mentions
          
          if (!nodeMap.has(mentionId)) {
            nodeMap.set(mentionId, {
              id: mentionId,
              label: mention.userUniqueId || String(mentionId),
              type: 'user', 
              followers: 0
            });
          }
          links.push({ source: authorId, target: mentionId, postId: post.item_id });
        });
      });

      console.log(`Mention network: ${nodeMap.size} nodes, ${links.length} links`);
      return { nodes: Array.from(nodeMap.values()), links };
    }

    function extractCoHashtagNetwork(posts) {
      const nodeMap = new Map();
      const linkMap = new Map();

      posts.forEach(post => {
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          const tagId = tag.id;
          if (!nodeMap.has(tagId)) nodeMap.set(tagId, { id: tagId, label: tag.title, count: 0, type: 'hashtag' });
          nodeMap.get(tagId).count++;
        });
        for (let i=0;i<hashtags.length;i++){
          for (let j=i+1;j<hashtags.length;j++){
            const source = hashtags[i].id, target = hashtags[j].id;
            const key = [source, target].sort().join('-');
            if (!linkMap.has(key)) linkMap.set(key, { source, target, weight: 0 });
            linkMap.get(key).weight++;
          }
        }
      });
      
      console.log(`Co-hashtag network: ${nodeMap.size} nodes, ${linkMap.size} links`);
      return { nodes: Array.from(nodeMap.values()), links: Array.from(linkMap.values()) };
    }

    function extractUserHashtagNetwork(posts) {
      const nodeMap = new Map();
      const links = [];

      posts.forEach(post => {
        const author = post.data?.author;
        if (!author) return;

        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId, label: author.uniqueId || author.nickname, type: 'user',
            verified: author.verified, followers: post.data?.authorStats?.followerCount || 0
          });
        }
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          const tagId = `h_${tag.id}`;
          if (!nodeMap.has(tagId)) nodeMap.set(tagId, { id: tagId, label: tag.title, type: 'hashtag', count: 0 });
          nodeMap.get(tagId).count++;
          links.push({ source: authorId, target: tagId, postId: post.item_id });
        });
      });

      return { nodes: Array.from(nodeMap.values()), links };
    }

    function extractHashtagNetwork(posts) {
      const nodeMap = new Map();
      posts.forEach(post => {
        const hashtags = post.data?.challenges || [];
        hashtags.forEach(tag => {
          if (!nodeMap.has(tag.id)) nodeMap.set(tag.id, { id: tag.id, label: tag.title, count: 0, totalEngagement: 0, type: 'hashtag' });
          const node = nodeMap.get(tag.id);
          node.count++;
          node.totalEngagement += (post.data?.stats?.diggCount || 0);
        });
      });
      return { nodes: Array.from(nodeMap.values()), links: [] };
    }

    // Instagram-specific: Photo tag network
    function extractPhotoTagNetwork(posts) {
      const nodeMap = new Map();
      const links = [];
      
      posts.forEach(post => {
        if (post.platform !== 'instagram') return; // Only Instagram has photo tags
        
        const author = post.data?.author;
        const usertags = post.data?._instagram?.usertags?.in || [];
        
        if (!author || usertags.length === 0) return;
        
        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            type: 'user',
            verified: author.verified,
            followers: 0
          });
        }
        
        // Create connections to tagged users
        usertags.forEach(tag => {
          const taggedUser = tag.user;
          if (!taggedUser) return;
          
          const taggedId = `u_${taggedUser.id}`;
          if (!nodeMap.has(taggedId)) {
            nodeMap.set(taggedId, {
              id: taggedId,
              label: taggedUser.username,
              type: 'user',
              verified: taggedUser.is_verified || false,
              followers: 0
            });
          }
          
          links.push({ source: authorId, target: taggedId, postId: post.item_id });
        });
      });
      
      return { nodes: Array.from(nodeMap.values()), links };
    }

    // Instagram-specific: Location network
    function extractLocationNetwork(posts) {
      const nodeMap = new Map();
      const links = [];
      
      posts.forEach(post => {
        if (post.platform !== 'instagram') return; // Only Instagram has location data
        
        const author = post.data?.author;
        const location = post.data?._instagram?.location;
        
        if (!author || !location) return;
        
        const authorId = `u_${author.id}`;
        if (!nodeMap.has(authorId)) {
          nodeMap.set(authorId, {
            id: authorId,
            label: author.uniqueId || author.nickname,
            type: 'user',
            verified: author.verified,
            followers: 0
          });
        }
        
        const locationId = `loc_${location.pk}`;
        if (!nodeMap.has(locationId)) {
          nodeMap.set(locationId, {
            id: locationId,
            label: location.name,
            type: 'location',
            count: 0,
            lat: location.lat,
            lng: location.lng
          });
        }
        
        nodeMap.get(locationId).count++;
        links.push({ source: authorId, target: locationId, postId: post.item_id });
      });
      
      return { nodes: Array.from(nodeMap.values()), links };
    }

    // =========================
    // Metrics & communities
    // =========================
    function calculateNetworkMetrics(graph) {
      const n = graph.nodes.length;
      const m = graph.links.length;
      if (n === 0) return null;

      const maxEdges = (n * (n - 1)) / 2;
      const density = maxEdges > 0 ? (m / maxEdges).toFixed(3) : 0;

      const degrees = new Map();
      graph.nodes.forEach(node => degrees.set(node.id, 0));
      graph.links.forEach(link => {
        degrees.set(link.source, (degrees.get(link.source) || 0) + 1);
        degrees.set(link.target, (degrees.get(link.target) || 0) + 1);
      });

      const avgDegree = (Array.from(degrees.values()).reduce((a,b)=>a+b,0) / n).toFixed(2);
      const maxDegree = degrees.size ? Math.max(...Array.from(degrees.values())) : 0;

      graph.nodes.forEach(node => { node.degree = degrees.get(node.id) || 0; });

      let totalClustering = 0, validNodes = 0;
      graph.nodes.forEach(node => {
        const neighbors = new Set();
        graph.links.forEach(link => {
          if (link.source === node.id) neighbors.add(link.target);
          if (link.target === node.id) neighbors.add(link.source);
        });
        const k = neighbors.size;
        if (k < 2) return;
        let triangles = 0;
        const arr = Array.from(neighbors);
        for (let i=0;i<arr.length;i++){
          for (let j=i+1;j<arr.length;j++){
            if (graph.links.some(l => (l.source===arr[i] && l.target===arr[j]) || (l.target===arr[i] && l.source===arr[j]))) triangles++;
          }
        }
        const possible = (k*(k-1))/2;
        if (possible > 0) { totalClustering += triangles/possible; validNodes++; }
      });
      const avgClustering = validNodes > 0 ? (totalClustering / validNodes).toFixed(3) : 0;

      return { nodes: n, edges: m, density, avgDegree, maxDegree, avgClustering };
    }

    function displayMetrics(metrics) {
      if (!metrics) { metricsPanel.style.display = 'none'; return; }
      metricsList.innerHTML = `
        <li><span class="metric-name">Nodes</span><span class="metric-value">${metrics.nodes}</span></li>
        <li><span class="metric-name">Edges</span><span class="metric-value">${metrics.edges}</span></li>
        <li><span class="metric-name">Density</span><span class="metric-value">${metrics.density}</span></li>
        <li><span class="metric-name">Avg Degree</span><span class="metric-value">${metrics.avgDegree}</span></li>
        <li><span class="metric-name">Max Degree</span><span class="metric-value">${metrics.maxDegree}</span></li>
        <li><span class="metric-name">Clustering</span><span class="metric-value">${metrics.avgClustering}</span></li>
      `;
      metricsPanel.style.display = 'block';
    }

    function detectCommunities(graph) {
      if (graph.nodes.length === 0 || graph.links.length === 0) return null;

      const adj = new Map();
      graph.nodes.forEach(n => adj.set(n.id, new Set()));
      graph.links.forEach(l => { adj.get(l.source).add(l.target); adj.get(l.target).add(l.source); });

      const labels = new Map();
      graph.nodes.forEach((n,i)=>labels.set(n.id, i));

      let changed = true, iterations = 0;
      const maxIterations = 100;

      while (changed && iterations < maxIterations) {
        changed = false; iterations++;
        const shuffled = [...graph.nodes].sort(() => Math.random()-0.5);
        shuffled.forEach(node => {
          const neighbors = adj.get(node.id); if (neighbors.size===0) return;
          const counts = new Map();
          neighbors.forEach(nb => { const lab = labels.get(nb); counts.set(lab, (counts.get(lab)||0)+1); });
          let best = labels.get(node.id), bestCount = 0;
          counts.forEach((c,lab)=>{ if (c>bestCount){ bestCount=c; best=lab; } });
          if (best !== labels.get(node.id)) { labels.set(node.id, best); changed = true; }
        });
      }
      const uniq = [...new Set(labels.values())];
      const remap = new Map(); uniq.forEach((lab,i)=>remap.set(lab,i));
      const out = new Map(); labels.forEach((lab,id)=>out.set(id, remap.get(lab)));
      return { communities: out, count: uniq.length };
    }

    // =========================
    // Update network
    // =========================
    function updateNetwork() {
      loading.classList.add('active');
      loadingText.textContent = 'Building network...';

      setTimeout(() => {
        const filtered = filterData();
        const networkType = networkTypeSelect.value;

        let network;
        switch (networkType) {
          case 'mention':     network = extractMentionNetwork(filtered);     break;
          case 'coHashtag':   network = extractCoHashtagNetwork(filtered);   break;
          case 'userHashtag': network = extractUserHashtagNetwork(filtered); break;
          case 'hashtag':     network = extractHashtagNetwork(filtered);     break;
          case 'photoTag':    network = extractPhotoTagNetwork(filtered);    break;
          case 'location':    network = extractLocationNetwork(filtered);    break;
          default:            network = { nodes: [], links: [] };
        }

        graphData = network;
        communities = null;
        cibDetection = null;

        networkMetrics = calculateNetworkMetrics(network);
        displayMetrics(networkMetrics);

        document.getElementById('stat-nodes').textContent = network.nodes.length;
        document.getElementById('stat-edges').textContent = network.links.length;
        document.getElementById('stat-density').textContent = networkMetrics ? networkMetrics.density : '0';
        document.getElementById('stat-communities').textContent = '0';
        document.getElementById('stat-suspicious').textContent = '0';

        cibPanel.style.display = 'none';

        // Check if network is empty
        if (network.nodes.length === 0 || network.links.length === 0) {
          loading.classList.remove('active');
          loadingText.textContent = `No ${networkType === 'mention' ? 'mentions' : 
                                      networkType === 'coHashtag' ? 'co-hashtags' : 
                                      networkType === 'hashtag' ? 'hashtags' : 
                                      networkType === 'userHashtag' ? 'user-hashtag connections' : 
                                      networkType === 'photoTag' ? 'photo tags' : 
                                      'location connections'} found in this dataset. Try a different network type.`;
          setTimeout(() => { loadingText.textContent = ''; }, 5000);
          return;
        }

        // Build adjacency (for degree/hover-neighbor glow) and an id->node map
        buildAdjacency(graphData);
        idToNode = new Map(graphData.nodes.map(n => [n.id, n]));

        initializeVisualization();
        loading.classList.remove('active');
        updateCoach();
      }, 100);
    }

    // =========================
    // GPU Renderer (WebGL)
    // =========================
    class GPUNetworkRenderer {
      constructor(canvas) {
        this.canvas = canvas;
        this.gl = null;
        this.edgeProgram = null;
        this.nodeProgram = null;
        this.edgeBuffers = null;
        this.nodeBuffers = null;
        this.textRenderer = null;
        this.initialized = false;
        
        this.initWebGL();
      }

      initWebGL() {
        console.log('=== WebGL Context Creation Diagnostics ===');
        console.log('Canvas element:', this.canvas);
        console.log('Canvas dimensions:', {
          width: this.canvas.width,
          height: this.canvas.height,
          offsetWidth: this.canvas.offsetWidth,
          offsetHeight: this.canvas.offsetHeight
        });
        
        try {
          // ✅ CRITICAL CHECK: Does canvas already have a NON-WebGL context?
          // IMPORTANT: Do NOT call getContext('2d') here — that would CREATE a 2D context.
          if (this.canvas.__ctxType && this.canvas.__ctxType !== 'webgl' && this.canvas.__ctxType !== 'webgl2') {
            console.error('❌ FATAL ERROR: Canvas already initialized with a non-WebGL context (' + this.canvas.__ctxType + ')');
            console.error('❌ Cannot create WebGL context on a canvas with an existing non-WebGL context');
            return false;
          }
          
          // CRITICAL FIX: Store and completely reset canvas state
          const computedStyle = window.getComputedStyle(this.canvas);
          const originalDisplay = computedStyle.display;
          const originalPosition = computedStyle.position;
          const originalVisibility = computedStyle.visibility;
          const originalTransform = computedStyle.transform;
          const originalOpacity = computedStyle.opacity;
          
          // CRITICAL FIX: Ensure canvas has proper dimensions BEFORE context creation
          const rect = this.canvas.getBoundingClientRect();
          if (this.canvas.width === 0 || this.canvas.height === 0) {
            console.log('❌ CRITICAL ISSUE: Canvas has zero dimensions - fixing...');
            this.canvas.width = Math.max(rect.width || this.canvas.offsetWidth || 800, 1);
            this.canvas.height = Math.max(rect.height || this.canvas.offsetHeight || 600, 1);
            console.log('✅ Fixed canvas dimensions:', {
              width: this.canvas.width,
              height: this.canvas.height
            });
          }
          
          // CRITICAL FIX: Temporarily remove any CSS that might interfere with WebGL
          // This is the key fix - CSS transforms and certain positioning can break WebGL
          this.canvas.style.setProperty('transform', 'none', 'important');
          this.canvas.style.setProperty('opacity', '1', 'important');
          this.canvas.style.setProperty('visibility', 'visible', 'important');
          this.canvas.style.setProperty('display', 'block', 'important');
          this.canvas.style.setProperty('position', 'static', 'important');
          this.canvas.style.setProperty('will-change', 'auto', 'important');
          this.canvas.style.setProperty('contain', 'none', 'important');
          
          // Force a reflow to apply the style changes
          this.canvas.offsetHeight;
          
          console.log('🔍 Testing WebGL with cleaned canvas state...');
          
          // CRITICAL FIX: Try WebGL context creation with optimal settings
          const contextAttributes = {
            alpha: false,
            antialias: true,
            depth: false,
            stencil: false,
            preserveDrawingBuffer: false,
            premultipliedAlpha: false,
            powerPreference: 'high-performance',
            failIfMajorPerformanceCaveat: false
          };
          
          // Try WebGL 2 first (better performance), then WebGL 1
          this.gl = this.canvas.getContext('webgl2', contextAttributes) ||
                    this.canvas.getContext('webgl', contextAttributes) ||
                    this.canvas.getContext('experimental-webgl', contextAttributes);
          
          if (!this.gl) {
            console.error('❌ WebGL context creation failed');
            console.error('❌ Possible causes:');
            console.error('   1. Browser extensions blocking WebGL (privacy/ad blockers)');
            console.error('   2. Hardware acceleration disabled in browser settings');
            console.error('   3. GPU blacklisted or unsupported');
            console.error('   4. Canvas already has a different context type');
            console.error('');
            console.error('💡 Try:');
            console.error('   - Open in incognito/private mode');
            console.error('   - Disable browser extensions temporarily');
            console.error('   - Check browser hardware acceleration settings');
            
            // Show user-friendly notification
            this.showWebGLDisabledNotification();
            console.warn('WebGL not supported, falling back to CPU rendering');
            return false;
          }
          
          // Tag the canvas so future checks don't probe/instantiate other contexts
          this.canvas.__ctxType = (this.gl.getParameter(this.gl.VERSION).indexOf('WebGL 2') !== -1) ? 'webgl2' : 'webgl';
          
          console.log('✅ WebGL context created successfully');
          console.log('WebGL context type:', this.gl.constructor.name);
          
          // CRITICAL FIX: Test if context is actually functional
          try {
            const gl = this.gl;
            gl.clearColor(1.0, 1.0, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            
            // Test basic drawing setup
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            
            console.log('✅ WebGL context is functional');
            
            // Log WebGL capabilities
            console.log('WebGL Version:', gl.getParameter(gl.VERSION));
            console.log('WebGL Vendor:', gl.getParameter(gl.VENDOR));
            console.log('WebGL Renderer:', gl.getParameter(gl.RENDERER));
            
            // Create shaders and buffers
            console.log('Creating WebGL shaders and buffers...');
            const shadersCreated = this.createShaders();
            const buffersCreated = this.createBuffers();
            
            console.log('Shader creation result:', shadersCreated);
            console.log('Buffer creation result:', buffersCreated);
            
            if (shadersCreated && buffersCreated) {
              this.initialized = true;
              console.log('✅ WebGL renderer fully initialized');
              
              // CRITICAL FIX: Don't restore canvas styles that could break WebGL
              // Keep the canvas in the clean state needed for WebGL
              this.canvas.style.setProperty('transform', 'none', 'important');
              this.canvas.style.setProperty('opacity', '1', 'important');
              this.canvas.style.setProperty('visibility', 'visible', 'important');
              this.canvas.style.setProperty('display', 'block', 'important');
              this.canvas.style.setProperty('position', 'static', 'important');
              
              return true;
            } else {
              console.error('❌ Failed to create shaders or buffers');
              return false;
            }
          } catch (glError) {
            console.error('❌ WebGL context is not functional:', glError);
            console.error('❌ Context created but drawing operations fail');
            return false;
          }
        } catch (error) {
          console.error('❌ WebGL initialization threw exception:', error);
          console.error('Error details:', {
            name: error.name,
            message: error.message,
            stack: error.stack
          });
          return false;
        }
      }

      showWebGLDisabledNotification() {
        // Create a user-friendly notification
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: #dc2626;
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
          font-size: 14px;
          z-index: 10000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          max-width: 400px;
          line-height: 1.4;
        `;
        notification.innerHTML = `
          <div style="font-weight: 600; margin-bottom: 8px;">⚠️ WebGL Disabled</div>
          <div style="font-size: 12px; margin-bottom: 8px;">Browser extensions or security policies are blocking WebGL.</div>
          <div style="font-size: 11px; opacity: 0.9;">Try disabling extensions or using incognito mode.</div>
        `;
        
        document.body.appendChild(notification);
        
        // Auto-remove after 8 seconds
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 8000);
        
        // Click to dismiss
        notification.addEventListener('click', () => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        });
      }

      createShaders() {
        const gl = this.gl;
        
        // Edge shader - draws lines between nodes
        const edgeVertexSource = `
          attribute vec2 a_position;
          attribute vec3 a_color;
          attribute float a_alpha;
          uniform vec2 u_resolution;
          varying vec3 v_color;
          varying float v_alpha;
          
          void main() {
            vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            v_color = a_color;
            v_alpha = a_alpha;
          }
        `;
        
        const edgeFragmentSource = `
          precision mediump float;
          varying vec3 v_color;
          varying float v_alpha;
          
          void main() {
            gl_FragColor = vec4(v_color, v_alpha);
          }
        `;
        
        // Node shader - draws circles for nodes
        const nodeVertexSource = `
          attribute vec2 a_position;
          attribute vec3 a_color;
          attribute float a_radius;
          attribute float a_borderWidth;
          attribute vec3 a_borderColor;
          uniform vec2 u_resolution;
          varying vec3 v_color;
          varying float v_radius;
          varying float v_borderWidth;
          varying vec3 v_borderColor;
          
          void main() {
            vec2 clipSpace = ((a_position / u_resolution) * 2.0) - 1.0;
            gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
            v_color = a_color;
            v_radius = a_radius;
            v_borderWidth = a_borderWidth;
            v_borderColor = a_borderColor;
            gl_PointSize = a_radius * 2.0 + a_borderWidth * 2.0;
          }
        `;
        
        const nodeFragmentSource = `
          precision mediump float;
          varying vec3 v_color;
          varying float v_radius;
          varying float v_borderWidth;
          varying vec3 v_borderColor;
          
          void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            
            if (dist > 0.5) {
              discard;
            }
            
            float totalRadius = v_radius + v_borderWidth;
            float normalizedDist = dist * 2.0; // 0 at center, 1 at edge
            
            if (v_borderWidth > 0.0 && normalizedDist > (v_radius / totalRadius)) {
              gl_FragColor = vec4(v_borderColor, 1.0);
            } else {
              gl_FragColor = vec4(v_color, 1.0);
            }
          }
        `;
        
        this.edgeProgram = this.createProgram(edgeVertexSource, edgeFragmentSource);
        this.nodeProgram = this.createProgram(nodeVertexSource, nodeFragmentSource);
        
        // Return true if both programs were created successfully
        return !!(this.edgeProgram && this.nodeProgram);
      }

      createProgram(vertexSource, fragmentSource) {
        const gl = this.gl;
        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
        
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program link failed:', gl.getProgramInfoLog(program));
          return null;
        }
        
        return program;
      }

      createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader compile failed:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        
        return shader;
      }

      createBuffers() {
        const gl = this.gl;
        
        try {
          // Edge buffers
          this.edgeBuffers = {
            position: gl.createBuffer(),
            color: gl.createBuffer(),
            alpha: gl.createBuffer()
          };
          
          // Node buffers
          this.nodeBuffers = {
            position: gl.createBuffer(),
            color: gl.createBuffer(),
            radius: gl.createBuffer(),
            borderWidth: gl.createBuffer(),
            borderColor: gl.createBuffer()
          };
          
          // Check if all buffers were created successfully
          const edgeBuffersValid = this.edgeBuffers.position && this.edgeBuffers.color && this.edgeBuffers.alpha;
          const nodeBuffersValid = this.nodeBuffers.position && this.nodeBuffers.color && 
                                 this.nodeBuffers.radius && this.nodeBuffers.borderWidth && this.nodeBuffers.borderColor;
          
          return !!(edgeBuffersValid && nodeBuffersValid);
        } catch (error) {
          console.error('Buffer creation failed:', error);
          return false;
        }
      }

      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
          parseInt(result[1], 16) / 255,
          parseInt(result[2], 16) / 255,
          parseInt(result[3], 16) / 255
        ] : [0.5, 0.5, 0.5];
      }

      render(nodes, edges, width, height) {
        if (!this.initialized) return false;
        
        const gl = this.gl;
        gl.viewport(0, 0, width, height);
        gl.clearColor(1, 1, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        this.renderEdges(edges, width, height);
        this.renderNodes(nodes, width, height);
        
        return true;
      }

      renderEdges(edges, width, height) {
        if (edges.length === 0) return;
        
        const gl = this.gl;
        gl.useProgram(this.edgeProgram);
        
        // Prepare edge data
        const positions = [];
        const colors = [];
        const alphas = [];
        
        edges.forEach(edge => {
          if (!edge.source || !edge.target) return;
          
          // Use idToNode map for better performance (optimization)
          const source = idToNode.get(edge.source);
          const target = idToNode.get(edge.target);
          if (!source || !target) return;
          
          // Create line segment
          positions.push(source.x, source.y, target.x, target.y);
          
          const weight = edge.weight || 1;
          const alpha = Math.min(0.3 + weight * 0.1, 0.8);
          const color = this.hexToRgb('#d1d5db');
          
          colors.push(...color, ...color);
          alphas.push(alpha, alpha);
        });
        
        if (positions.length === 0) return;
        
        // Set uniforms
        const resolutionLocation = gl.getUniformLocation(this.edgeProgram, 'u_resolution');
        if (resolutionLocation) {
          gl.uniform2f(resolutionLocation, width, height);
        }
        
        // Set attributes
        const positionLocation = gl.getAttribLocation(this.edgeProgram, 'a_position');
        if (positionLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.position);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }
        
        const colorLocation = gl.getAttribLocation(this.edgeProgram, 'a_color');
        if (colorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.color);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(colorLocation);
          gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        const alphaLocation = gl.getAttribLocation(this.edgeProgram, 'a_alpha');
        if (alphaLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.edgeBuffers.alpha);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(alphas), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(alphaLocation);
          gl.vertexAttribPointer(alphaLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        // Draw edges as lines
        gl.drawArrays(gl.LINES, 0, positions.length / 2);
      }

      renderNodes(nodes, width, height) {
        if (nodes.length === 0) return;
        
        const gl = this.gl;
        gl.useProgram(this.nodeProgram);
        
        // Prepare node data
        const positions = [];
        const colors = [];
        const radii = [];
        const borderWidths = [];
        const borderColors = [];
        
        nodes.forEach(node => {
          positions.push(node.x, node.y);
          
          const color = this.hexToRgb(getNodeColor(node));
          colors.push(...color);
          
          const radius = nodeSize(node);
          radii.push(radius);
          
          // Border styling
          if (node.suspicious) {
            borderWidths.push(3);
            borderColors.push(...this.hexToRgb('#7f1d1d'));
          } else if (radius > 12) {
            borderWidths.push(2);
            borderColors.push(...this.hexToRgb('#ffffff'));
          } else {
            borderWidths.push(0);
            borderColors.push(...color);
          }
        });
        
        // Set uniforms
        const resolutionLocation = gl.getUniformLocation(this.nodeProgram, 'u_resolution');
        if (resolutionLocation) {
          gl.uniform2f(resolutionLocation, width, height);
        }
        
        // Set attributes manually with proper error checking
        const positionLocation = gl.getAttribLocation(this.nodeProgram, 'a_position');
        if (positionLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.position);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
        }
        
        const colorLocation = gl.getAttribLocation(this.nodeProgram, 'a_color');
        if (colorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.color);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(colorLocation);
          gl.vertexAttribPointer(colorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        const radiusLocation = gl.getAttribLocation(this.nodeProgram, 'a_radius');
        if (radiusLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.radius);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(radii), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(radiusLocation);
          gl.vertexAttribPointer(radiusLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        const borderWidthLocation = gl.getAttribLocation(this.nodeProgram, 'a_borderWidth');
        if (borderWidthLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.borderWidth);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(borderWidths), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(borderWidthLocation);
          gl.vertexAttribPointer(borderWidthLocation, 1, gl.FLOAT, false, 0, 0);
        }
        
        const borderColorLocation = gl.getAttribLocation(this.nodeProgram, 'a_borderColor');
        if (borderColorLocation >= 0) {
          gl.bindBuffer(gl.ARRAY_BUFFER, this.nodeBuffers.borderColor);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(borderColors), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(borderColorLocation);
          gl.vertexAttribPointer(borderColorLocation, 3, gl.FLOAT, false, 0, 0);
        }
        
        // Draw nodes as points
        gl.drawArrays(gl.POINTS, 0, nodes.length);
      }

      setAttribute(program, name, data, size) {
        const gl = this.gl;
        const location = gl.getAttribLocation(program, name);
        const buffer = name.includes('position') ? this.nodeBuffers.position :
                       name.includes('color') ? this.nodeBuffers.color :
                       name.includes('radius') ? this.nodeBuffers.radius :
                       name.includes('borderWidth') ? this.nodeBuffers.borderWidth :
                       name.includes('borderColor') ? this.nodeBuffers.borderColor :
                       this.edgeBuffers.position;
        
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW);
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, size, gl.FLOAT, false, 0, 0);
      }

      renderLabels(nodes, width, height) {
        // CRITICAL FIX: Cannot create 2D context on canvas with WebGL context
        // Instead, create a temporary overlay canvas for text rendering
        const overlayCanvas = document.createElement('canvas');
        overlayCanvas.width = width;
        overlayCanvas.height = height;
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '1';
        
        const ctx = overlayCanvas.getContext('2d');
        if (!ctx) return;
        
        ctx.save();
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillStyle = '#1f2937';
        
        nodes.forEach(node => {
          const radius = nodeSize(node);
          if (radius > 8) {
            const label = (node.label || '').substring(0, 20);
            ctx.fillText(label, node.x, node.y - radius - 5);
          }
        });
        
        ctx.restore();
        
        // Replace any existing overlay
        const existingOverlay = this.canvas.parentNode.querySelector('.text-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // Add the overlay
        overlayCanvas.className = 'text-overlay';
        this.canvas.parentNode.appendChild(overlayCanvas);
      }

      renderArrows(edges, width, height) {
        // Render arrows on overlay for GPU mode (WebGL arrows are complex)
        const overlayCanvas = document.createElement('canvas');
        overlayCanvas.width = width;
        overlayCanvas.height = height;
        overlayCanvas.style.position = 'absolute';
        overlayCanvas.style.top = '0';
        overlayCanvas.style.left = '0';
        overlayCanvas.style.pointerEvents = 'none';
        overlayCanvas.style.zIndex = '0.5';
        
        const ctx = overlayCanvas.getContext('2d');
        if (!ctx) return;
        
        ctx.save();
        edges.forEach(edge => {
          const s = idToNode.get(edge.source);
          const t = idToNode.get(edge.target);
          if (!s || !t) return;
          
          const angle = Math.atan2(t.y - s.y, t.x - s.x);
          const targetRadius = nodeSize(t);
          const arrowSize = Math.min(8, targetRadius * 0.6);
          const arrowX = t.x - Math.cos(angle) * (targetRadius + 2);
          const arrowY = t.y - Math.sin(angle) * (targetRadius + 2);
          
          const w = edge.weight || 1;
          ctx.globalAlpha = Math.min(0.3 + w * 0.1, 0.8);
          ctx.fillStyle = '#d1d5db';
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();
        });
        ctx.restore();
        
        // Replace any existing arrow overlay
        const existingOverlay = this.canvas.parentNode.querySelector('.arrow-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // Add the overlay
        overlayCanvas.className = 'arrow-overlay';
        this.canvas.parentNode.appendChild(overlayCanvas);
      }

      cleanup() {
        if (!this.initialized) return;
        
        const gl = this.gl;
        Object.values(this.edgeBuffers).forEach(buffer => gl.deleteBuffer(buffer));
        Object.values(this.nodeBuffers).forEach(buffer => gl.deleteBuffer(buffer));
        
        if (this.edgeProgram) gl.deleteProgram(this.edgeProgram);
        if (this.nodeProgram) gl.deleteProgram(this.nodeProgram);
      }
    }

    // =========================
    // Layouts & drawing (GPU-accelerated)
    // =========================
    function applyForceLayout() {
      const centerX = canvas.width / 2, centerY = canvas.height / 2;
      const maxRepulsionDist = 300; // Skip repulsion for distant nodes (optimization)
      
      nodes.forEach(node => {
        nodes.forEach(other => {
          if (node === other) return;
          const dx = node.x - other.x, dy = node.y - other.y;
          const distSq = dx*dx + dy*dy;
          
          // Skip repulsion for very distant nodes (optimization)
          if (distSq > maxRepulsionDist * maxRepulsionDist) return;
          
          const dist = Math.sqrt(distSq) || 1;
          const force = Math.min(1000 / distSq, 10);
          node.vx += (dx / dist) * force;
          node.vy += (dy / dist) * force;
        });
        graphData.links.forEach(link => {
          // Use idToNode map for better performance (optimization)
          const source = idToNode.get(link.source);
          const target = idToNode.get(link.target);
          if (!source || !target) return;
          if (node === source) {
            const dx = target.x - source.x, dy = target.y - source.y;
            const dist = Math.sqrt(dx*dx + dy*dy) || 1;
            const force = (dist - 150) * 0.05;
            node.vx += (dx / dist) * force;
            node.vy += (dy / dist) * force;
          }
        });
        node.vx += (centerX - node.x) * 0.002;
        node.vy += (centerY - node.y) * 0.002;
        node.vx *= 0.85; node.vy *= 0.85;
        node.x += node.vx; node.y += node.vy;
        const margin = 30;
        node.x = Math.max(margin, Math.min(canvas.width - margin, node.x));
        node.y = Math.max(margin, Math.min(canvas.height - margin, node.y));
      });
    }

    function initializeVisualization() {
      if (!graphData || graphData.nodes.length === 0) {
        if (ctx) ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetHeight;

      nodes = graphData.nodes.map(n => ({
        ...n,
        x: canvas.width/2 + (Math.random()-0.5)*100,
        y: canvas.height/2 + (Math.random()-0.5)*100,
        vx: 0, vy: 0
      }));

      // Update global nodes reference for WebGL renderer
      window.nodes = nodes;
      
      // Rebuild idToNode map with positioned nodes (fix for highlight bug)
      idToNode = new Map(nodes.map(n => [n.id, n]));

      // CRITICAL FIX: Initialize GPU renderer FIRST, before any 2D context creation
      // This prevents the "Canvas already has a 2D context" error
      if (!gpuRenderer) {
        console.log('Attempting GPU renderer initialization...');
        gpuRenderer = new GPUNetworkRenderer(canvas);
        
        if (!gpuRenderer || !gpuRenderer.initialized) {
          console.log('GPU renderer failed, will use CPU rendering');
          gpuRenderer = null;
          // Only create 2D context if WebGL failed
          if (!ctx) {
            if (!gl && !gpuRenderer) {
              ctx = canvas.getContext('2d');
              canvas.__ctxType = '2d';
            }
          }
        }
      }

      startAnimation();
    }

    function startAnimation() {
      if (animationFrame) cancelAnimationFrame(animationFrame);
      let iteration = 0, maxIterations = 200;
      function animate() {
        if (iteration++ > maxIterations) return;
        applyForceLayout(); drawNetwork();
        animationFrame = requestAnimationFrame(animate);
      }
      animate();
    }

    function getNodeColor(node) {
      if (node.suspicious) return '#dc2626';
      if (communities && communities.communities.has(node.id)) {
        const cid = communities.communities.get(node.id);
        return communityColors[cid % communityColors.length];
      }
      if (node.type === 'user') return node.verified ? '#3b82f6' : '#8b5cf6';
      if (node.type === 'location') return '#f59e0b'; // Orange for locations
      return '#10b981'; // Green for hashtags
    }

    function nodeSize(n) {
      const sizeBy = nodeSizeBySelect.value;
      
      switch (sizeBy) {
        case 'degree':
          const degree = n.degree || 0;
          return Math.min(5 + Math.sqrt(degree) * 3, 30);
        
        case 'followers':
          if (n.type === 'user') {
            return Math.min(5 + Math.log((n.followers || 0) + 1) * 1.5, 25);
          } else {
            // For hashtags and locations, size by count
            return Math.min(5 + (n.count || 1) * 1.5, 25);
          }
        
        case 'uniform':
          return 8;
        
        default:
          return 8;
      }
    }

    function drawNetwork() {
      // Clean up any existing overlays before redrawing
      cleanupOverlays();
      
      // Try GPU rendering first, fallback to CPU if needed
      if (gpuRenderer && gpuRenderer.initialized) {
        const success = gpuRenderer.render(nodes, graphData.links, canvas.width, canvas.height);
        if (success) {
          // Render arrows and labels using Canvas 2D overlays
          gpuRenderer.renderArrows(graphData.links, canvas.width, canvas.height);
          gpuRenderer.renderLabels(nodes, canvas.width, canvas.height);
          updateRenderingIndicator(true);
          return;
        }
      }
      
      // Fallback to CPU rendering
      drawNetworkCPU();
      updateRenderingIndicator(false);
    }

    function cleanupOverlays() {
      // Remove any existing overlay canvases
      const container = canvas.parentNode;
      const overlays = container.querySelectorAll('.text-overlay, .arrow-overlay, .highlight-overlay, .search-highlight-overlay, .hover-overlay');
      overlays.forEach(overlay => overlay.remove());
    }

    function updateRenderingIndicator(isGPU) {
      if (isGPU) {
        renderingIndicator.textContent = '🚀 GPU rendering';
        renderingIndicator.style.color = '#10b981';
      } else {
        renderingIndicator.textContent = '⚙ CPU rendering';
        renderingIndicator.style.color = '#f59e0b';
      }
    }

    function drawNetworkCPU() {
      // Create 2D context on demand if not already created
      if (!ctx) {
        if (!gl && !gpuRenderer) {
          ctx = canvas.getContext('2d');
          canvas.__ctxType = '2d';
        }
        if (!ctx) {
          console.error('Failed to create 2D context');
          return;
        }
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // edges (use idToNode map instead of find for better performance)
      graphData.links.forEach(link => {
        const s = idToNode.get(link.source);
        const t = idToNode.get(link.target);
        if (!s || !t) return;
        const w = link.weight || 1;
        ctx.lineWidth = Math.min(1 + w*0.5, 5);
        ctx.strokeStyle = '#d1d5db';
        ctx.globalAlpha = Math.min(0.3 + w*0.1, 0.8);
        ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(t.x, t.y); ctx.stroke();
        
        // Draw arrowhead to show direction
        const angle = Math.atan2(t.y - s.y, t.x - s.x);
        const targetRadius = nodeSize(t);
        const arrowSize = Math.min(8, targetRadius * 0.6);
        const arrowX = t.x - Math.cos(angle) * (targetRadius + 2);
        const arrowY = t.y - Math.sin(angle) * (targetRadius + 2);
        
        ctx.fillStyle = '#d1d5db';
        ctx.beginPath();
        ctx.moveTo(arrowX, arrowY);
        ctx.lineTo(
          arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
          arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
          arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
          arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
        
        ctx.globalAlpha = 1;
      });

      // nodes
      nodes.forEach(n => {
        const r = nodeSize(n);
        ctx.fillStyle = getNodeColor(n);
        ctx.beginPath(); ctx.arc(n.x, n.y, r, 0, Math.PI*2); ctx.fill();

        if (r > 12 || n.suspicious) {
          ctx.strokeStyle = n.suspicious ? '#7f1d1d' : 'white';
          ctx.lineWidth = n.suspicious ? 3 : 2; ctx.stroke();
        }

        if (r > 8) {
          ctx.fillStyle = '#1f2937';
          ctx.font = `${Math.min(r*0.8, 12)}px sans-serif`;
          ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
          const label = (n.label || '').substring(0, 20);
          ctx.fillText(label, n.x, n.y - r - 5);
        }
      });
    }

    // =========================
    // Hover & Click UX
    // =========================
    function getNodeAt(x, y) {
      if (!nodes?.length) return null;
      let best = null, bestDist = Infinity;
      for (const n of nodes) {
        const r = nodeSize(n);
        const d = Math.hypot(x - n.x, y - n.y);
        if (d <= r && d < bestDist) { best = n; bestDist = d; }
      }
      return best;
    }

    function buildAdjacency(graph) {
      adjacency = new Map();
      graph.nodes.forEach(n => adjacency.set(n.id, new Set()));
      graph.links.forEach(l => {
        if (adjacency.has(l.source)) adjacency.get(l.source).add(l.target);
        if (adjacency.has(l.target)) adjacency.get(l.target).add(l.source);
      });
      graph.nodes.forEach(n => { n.degree = adjacency.get(n.id)?.size || 0; });
    }

    function postEngagement(p) {
      const s = p?.data?.stats || {};
      return (s.diggCount||0) + (s.commentCount||0) + (s.shareCount||0);
    }

    function getAllPostsForNode(node) {
      if (!filteredData?.length) return [];
      const out = [];
      if (node.type === 'user') {
        const wantId = (node.id + '').replace(/^u_/,'');
        for (const p of filteredData) {
          const a = p?.data?.author || {};
          if (String(a.id) === wantId || (a.uniqueId && node.label && a.uniqueId.toLowerCase() === node.label.toLowerCase())) {
            out.push(p);
          }
        }
      } else if (node.type === 'hashtag') {
        const wantId = (node.id + '').replace(/^h_/,'');
        const wantLabel = (node.label || '').toLowerCase();
        for (const p of filteredData) {
          const hs = p?.data?.challenges || [];
          if (hs.some(h => String(h.id) === wantId || (h.title && h.title.toLowerCase() === wantLabel))) out.push(p);
        }
      } else if (node.type === 'location') {
        const wantId = (node.id + '').replace(/^loc_/,'');
        const wantLabel = (node.label || '').toLowerCase();
        for (const p of filteredData) {
          const loc = p?.data?._instagram?.location;
          if (loc && (String(loc.pk) === wantId || (loc.name && loc.name.toLowerCase() === wantLabel))) {
            out.push(p);
          }
        }
      }
      out.sort((a,b)=>postEngagement(b)-postEngagement(a));
      return out;
    }

    function samplePostsForNode(node, limit=5) {
      return getAllPostsForNode(node).slice(0, limit);
    }

    function highlightNeighbors(node) {
      const nbs = adjacency.get(node.id) || new Set();
      
      // For GPU rendering, we need to render the highlight effect
      if (gpuRenderer && gpuRenderer.initialized) {
        // Create highlight data for GPU rendering
        const highlightNodes = [];
        for (const id of nbs) {
          const nb = idToNode.get(id); 
          if (!nb) continue;
          highlightNodes.push({
            x: nb.x,
            y: nb.y,
            radius: nodeSize(nb) + 8,
            color: [1.0, 0.96, 0.42], // #fde68a in RGB
            alpha: 0.15
          });
        }
        renderHighlightGlow(highlightNodes, node, nbs);
      } else {
        // Fallback to CPU rendering - highlight neighbor nodes
      ctx.save(); ctx.globalAlpha = 0.15; ctx.fillStyle = '#fde68a';
      for (const id of nbs) {
        const nb = idToNode.get(id); if (!nb) continue;
        ctx.beginPath(); ctx.arc(nb.x, nb.y, nodeSize(nb)+8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();
        
        // Highlight connected edges
        ctx.save();
        graphData.links.forEach(link => {
          const isConnected = (link.source === node.id && nbs.has(link.target)) ||
                             (link.target === node.id && nbs.has(link.source));
          if (!isConnected) return;
          
          // Use idToNode map for better performance (optimization)
          const s = idToNode.get(link.source);
          const t = idToNode.get(link.target);
          if (!s || !t) return;
          
          const w = link.weight || 1;
          ctx.lineWidth = Math.min(2 + w*0.5, 6);
          ctx.strokeStyle = '#fbbf24'; // Amber color for highlighted edges
          ctx.globalAlpha = 0.8;
          ctx.beginPath(); 
          ctx.moveTo(s.x, s.y); 
          ctx.lineTo(t.x, t.y); 
          ctx.stroke();
          
          // Draw arrowhead on highlighted edge
          const angle = Math.atan2(t.y - s.y, t.x - s.x);
          const targetRadius = nodeSize(t);
          const arrowSize = Math.min(10, targetRadius * 0.7);
          const arrowX = t.x - Math.cos(angle) * (targetRadius + 2);
          const arrowY = t.y - Math.sin(angle) * (targetRadius + 2);
          
          ctx.fillStyle = '#fbbf24';
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fill();
        });
        ctx.restore();
      }
    }

    function renderHighlightGlow(highlightNodes, node, nbs) {
      // CRITICAL FIX: Cannot create 2D context on canvas with WebGL context
      // Create a temporary overlay canvas for highlight effects
      const overlayCanvas = document.createElement('canvas');
      overlayCanvas.width = canvas.width;
      overlayCanvas.height = canvas.height;
      overlayCanvas.style.position = 'absolute';
      overlayCanvas.style.top = '0';
      overlayCanvas.style.left = '0';
      overlayCanvas.style.pointerEvents = 'none';
      overlayCanvas.style.zIndex = '2';
      
      const tempCtx = overlayCanvas.getContext('2d');
      
      // Draw highlighted edges first (so they appear behind nodes)
      if (node && nbs) {
        tempCtx.save();
        graphData.links.forEach(link => {
          const isConnected = (link.source === node.id && nbs.has(link.target)) ||
                             (link.target === node.id && nbs.has(link.source));
          if (!isConnected) return;
          
          // Use idToNode map for better performance (optimization)
          const s = idToNode.get(link.source);
          const t = idToNode.get(link.target);
          if (!s || !t) return;
          
          const w = link.weight || 1;
          tempCtx.lineWidth = Math.min(2 + w*0.5, 6);
          tempCtx.strokeStyle = '#fbbf24'; // Amber color for highlighted edges
          tempCtx.globalAlpha = 0.8;
          tempCtx.beginPath(); 
          tempCtx.moveTo(s.x, s.y); 
          tempCtx.lineTo(t.x, t.y); 
          tempCtx.stroke();
          
          // Draw arrowhead on highlighted edge
          const angle = Math.atan2(t.y - s.y, t.x - s.x);
          const targetRadius = nodeSize(t);
          const arrowSize = Math.min(10, targetRadius * 0.7);
          const arrowX = t.x - Math.cos(angle) * (targetRadius + 2);
          const arrowY = t.y - Math.sin(angle) * (targetRadius + 2);
          
          tempCtx.fillStyle = '#fbbf24';
          tempCtx.beginPath();
          tempCtx.moveTo(arrowX, arrowY);
          tempCtx.lineTo(
            arrowX - arrowSize * Math.cos(angle - Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle - Math.PI / 6)
          );
          tempCtx.lineTo(
            arrowX - arrowSize * Math.cos(angle + Math.PI / 6),
            arrowY - arrowSize * Math.sin(angle + Math.PI / 6)
          );
          tempCtx.closePath();
          tempCtx.fill();
        });
        tempCtx.restore();
      }
      
      // Draw highlighted nodes
      tempCtx.save();
      highlightNodes.forEach(node => {
        tempCtx.globalAlpha = node.alpha;
        tempCtx.fillStyle = `rgb(${Math.floor(node.color[0]*255)}, ${Math.floor(node.color[1]*255)}, ${Math.floor(node.color[2]*255)})`;
        tempCtx.beginPath();
        tempCtx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
        tempCtx.fill();
      });
      tempCtx.restore();
      
      // Remove any existing highlight overlay
      const existingHighlight = canvas.parentNode.querySelector('.highlight-overlay');
      if (existingHighlight) {
        existingHighlight.remove();
      }
      
      // Add the highlight overlay
      overlayCanvas.className = 'highlight-overlay';
      canvas.parentNode.appendChild(overlayCanvas);
    }

    canvas.addEventListener('mousemove', (e) => {
      if (!nodes?.length) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;

      const n = getNodeAt(x, y);
      if (n) {
        hoveredNode = n;
        canvas.classList.add('hovering');

        // tooltip content
        const deg = n.degree ?? 0;
        const label = n.label ?? n.id;
        let prefix = '';
        if (n.type === 'user') prefix = '@';
        else if (n.type === 'hashtag') prefix = '#';
        else if (n.type === 'location') prefix = '📍';
        
        const meta = (n.type==='user')
          ? `${n.verified?'Verified · ':''}${(n.followers||0).toLocaleString()} followers`
          : `${n.count||0} posts`;

        tooltipEl.innerHTML =
          `<div style="font-weight:600">${prefix}${label}</div>
           <div style="opacity:.85">${n.type} · degree ${deg}${meta ? ' · ' + meta : ''}</div>`;
        tooltipEl.style.display = 'block';

        // place tooltip
        const pad = 12;
        let tx = e.clientX + 12, ty = e.clientY + 12;
        const vw = window.innerWidth, vh = window.innerHeight;
        tooltipEl.style.left = tx + 'px'; tooltipEl.style.top = ty + 'px';
        const tb = tooltipEl.getBoundingClientRect();
        if (tx + tb.width + pad > vw) tooltipEl.style.left = (vw - tb.width - pad) + 'px';
        if (ty + tb.height + pad > vh) tooltipEl.style.top  = (vh - tb.height - pad) + 'px';

        // redraw with neighbor glow + ring
        drawNetwork();
        highlightNeighbors(n);
        
        // Draw hover ring using overlay to avoid context conflicts
        const hoverCanvas = document.createElement('canvas');
        hoverCanvas.width = canvas.width;
        hoverCanvas.height = canvas.height;
        hoverCanvas.style.position = 'absolute';
        hoverCanvas.style.top = '0';
        hoverCanvas.style.left = '0';
        hoverCanvas.style.pointerEvents = 'none';
        hoverCanvas.style.zIndex = '4';
        
        const hoverCtx = hoverCanvas.getContext('2d');
        hoverCtx.save(); 
        hoverCtx.strokeStyle = '#111827'; 
        hoverCtx.lineWidth = 2; 
        hoverCtx.globalAlpha = 0.6;
        hoverCtx.beginPath(); 
        hoverCtx.arc(n.x, n.y, nodeSize(n)+4, 0, Math.PI*2); 
        hoverCtx.stroke(); 
        hoverCtx.restore();
        
        // Remove any existing hover overlay
        const existingHover = canvas.parentNode.querySelector('.hover-overlay');
        if (existingHover) {
          existingHover.remove();
        }
        
        // Add the hover overlay
        hoverCanvas.className = 'hover-overlay';
        canvas.parentNode.appendChild(hoverCanvas);
      } else {
        hoveredNode = null;
        canvas.classList.remove('hovering');
        tooltipEl.style.display = 'none';
        drawNetwork();
      }
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;

      let clicked = null, minDist = Infinity;
      nodes.forEach(n => {
        const r = nodeSize(n);
        const d = Math.hypot(x - n.x, y - n.y);
        if (d < r && d < minDist) { clicked = n; minDist = d; }
      });

      if (clicked) {
        showNodeInfo(clicked);   // keep sidebar
        openNodeModal(clicked);  // new rich modal
      }
    });

    function openNodeModal(node) {
      let prefix = '';
      if (node.type === 'user') prefix = '@';
      else if (node.type === 'hashtag') prefix = '#';
      else if (node.type === 'location') prefix = '📍';
      modalTitle.textContent = `${prefix}${node.label || node.id}`;

      const nbs = Array.from(adjacency.get(node.id) || []);
      const neighborHTML = nbs.slice(0, 14).map(id => {
        const lab = idToNode.get(id)?.label || id;
        return `<code style="background:#f3f4f6; padding:.15rem .35rem; border-radius:6px; margin:.12rem; display:inline-block;">${lab}</code>`;
      }).join('');

      // Get all posts for hashtag and location nodes, sample for user nodes
      const posts = (node.type === 'hashtag' || node.type === 'location') ? getAllPostsForNode(node) : samplePostsForNode(node, 6);
      const postsHTML = posts.map(p => {
        const a = p?.data?.author || {};
        const platform = p.platform || 'unknown';
        
        // Platform-specific URLs and icons
        let profileUrl, postUrl, platformIcon;
        if (platform === 'instagram') {
          profileUrl = a?.uniqueId ? `https://www.instagram.com/${a.uniqueId}` : null;
          // Construct Instagram URL from code (and optionally username)
          const postCode = p?.data?.code || p?.code || p?.data?.pk;
          const username = a?.uniqueId || p?.data?.user?.username;
          postUrl = postCode ? (username ? `https://www.instagram.com/${username}/p/${postCode}/` : `https://www.instagram.com/p/${postCode}/`) : null;
          platformIcon = '📷';
        } else if (platform === 'tiktok') {
          profileUrl = a?.uniqueId ? `https://www.tiktok.com/@${a.uniqueId}` : null;
          // Construct TikTok URL from username and video ID
          const username = a?.uniqueId;
          const videoId = p?.data?.id || p?.id;
          postUrl = (username && videoId) ? `https://www.tiktok.com/@${username}/video/${videoId}` : 
                    (p?.tiktok_url || p?.data?.tiktok_url || p?.data?.webVideoUrl || p?.data?.shareUrl || null);
          platformIcon = '🎵';
        } else if (platform === 'twitter') {
          profileUrl = a?.uniqueId ? `https://x.com/${a.uniqueId}` : null;
          // Construct Twitter/X URL from username and tweet ID
          const username = a?.uniqueId;
          const tweetId = p?.data?.id || p?.id;
          postUrl = (username && tweetId) ? `https://x.com/${username}/status/${tweetId}` : null;
          platformIcon = '🐦';
        } else {
          profileUrl = null;
          postUrl = null;
          platformIcon = '❓';
        }
        
        const cap = (p?.data?.desc || '').slice(0, 220).replace(/</g,'<');
        const eng = postEngagement(p);
        const t = p?.data?.createTime ? new Date(p.data.createTime*1000).toLocaleString() : '';
        
        // Instagram-specific: location
        const location = p?.data?._instagram?.location;
        const locationText = location ? ` · 📍 ${location.name}` : '';
        
        const postLink = postUrl 
          ? `<a href="${postUrl}" target="_blank" rel="noopener" style="color:#059669; text-decoration:underline; font-weight:600;">🔗 view post</a>`
          : `<span style="color:#9ca3af; font-size:0.75rem;">no link available</span>`;
        
        return `<div style="padding:.6rem .6rem; border:1px solid #eee; border-radius:8px; margin:.45rem 0;">
          <div style="display:flex; justify-content:space-between; align-items:start; gap:0.5rem;">
            <div style="font-weight:600; flex:1;">${platformIcon} ${a.uniqueId ? '@'+a.uniqueId : '(unknown user)'}</div>
            <div style="flex-shrink:0;">${postLink}</div>
          </div>
          <div style="opacity:.95; margin-top:0.25rem;">${cap}${cap.length===220?'…':''}</div>
          <div style="opacity:.7; margin-top:.2rem">time: ${t} · engagement: ${eng.toLocaleString()}${locationText}</div>
        </div>`;
      }).join('');

      const teach = (() => {
        const deg = node.degree ?? 0;
        if (deg >= 12) return `This is a high-degree ${node.type}. Hubs can shape attention flows. Are neighbors from diverse communities, or mostly one echo chamber?`;
        if (deg <= 1)  return `This ${node.type} has very few connections. Is it peripheral, new, or filtered out by thresholds?`;
        return `Mid-degree ${node.type}. Check neighbors and example posts to see whether it bridges topics or audiences.`;
      })();

      const postsSectionTitle = (node.type === 'hashtag' || node.type === 'location')
        ? `All posts (${posts.length})` 
        : `Example posts (${posts.length})`;

      const postsContainerStyle = (node.type === 'hashtag' || node.type === 'location') 
        ? `max-height:300px; overflow-y:auto; border:1px solid #e5e7eb; border-radius:8px; padding:.5rem; background:#fafafa;`
        : '';

      modalBody.innerHTML = `
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin-bottom:8px;">
          <div><div class="small" style="color:#6b7280;">Type</div><div><b>${node.type}</b></div></div>
          <div><div class="small" style="color:#6b7280;">Degree</div><div><b>${node.degree ?? 0}</b></div></div>
          ${node.type==='user'
            ? `<div><div class="small" style="color:#6b7280;">Followers</div><div><b>${(node.followers||0).toLocaleString()}</b></div></div>
               <div><div class="small" style="color:#6b7280;">Verified</div><div><b>${node.verified? 'Yes':'No'}</b></div></div>`
            : node.type==='location'
            ? `<div><div class="small" style="color:#6b7280;">Posts at location</div><div><b>${node.count||0}</b></div></div>
               <div><div class="small" style="color:#6b7280;">Coordinates</div><div><b>${node.lat?.toFixed(4) || '?'}, ${node.lng?.toFixed(4) || '?'}</b></div></div>`
            : `<div><div class="small" style="color:#6b7280;">Usage count</div><div><b>${node.count||0}</b></div></div><div></div>`}
        </div>

        ${node.suspicious ? `
        <div class="warning-box" style="margin:.5rem 0;">
          <div style="font-weight:700; color:#991b1b; margin-bottom:.4rem;">⚠️ CIB DETECTED (Risk Score: ${node.cibScore}/100)</div>
          <div style="font-size:0.75rem; color:#7f1d1d; margin-bottom:.3rem;"><b>Indicators triggered:</b></div>
          <ul style="margin:0; padding-left:1.2rem; list-style:disc;">
            ${(node.cibReasons || []).map(reason => `<li style="margin:.15rem 0; color:#991b1b;">${reason}</li>`).join('')}
          </ul>
          <p style="margin-top:.4rem;"><strong>Note:</strong> These are behavioral indicators. Verify with manual inspection before drawing conclusions.</p>
        </div>
        ` : ''}

        <div class="small" style="background:#fff7ed; border:1px solid #fde7c7; padding:.6rem .7rem; border-radius:8px; margin:.4rem 0;">
          <b>Why it matters:</b> ${teach}
        </div>

        <div style="margin:.6rem 0 .25rem; font-weight:700;">Neighbors (${nbs.length})</div>
        <div>${neighborHTML || '<span class="small" style="color:#6b7280;">No neighbors</span>'}</div>

        <div style="margin:.9rem 0 .35rem; font-weight:700;">${postsSectionTitle}</div>
        <div style="${postsContainerStyle}">
          ${postsHTML || '<div class="small" style="color:#6b7280;">No posts found for this node given current filters.</div>'}
        </div>
        ${(node.type === 'hashtag' || node.type === 'location') && posts.length > 0 ? 
          `<div class="small" style="color:#6b7280; margin-top:.25rem; text-align:center;">Scroll to see all ${posts.length} posts</div>` : ''}
      `;
      modalEl.style.display = 'flex';
    }
    modalClose.addEventListener('click', ()=> modalEl.style.display = 'none');
    modalEl.addEventListener('click', (e)=> { if (e.target === modalEl) modalEl.style.display = 'none'; });

    function showNodeInfo(node) {
      let html = `<div class="info-row"><span class="info-label">Label:</span> <span class="info-value">${node.label}</span></div>`;
      html += `<div class="info-row"><span class="info-label">Type:</span> <span class="info-value">${node.type}</span></div>`;
      if (node.degree !== undefined) html += `<div class="info-row"><span class="info-label">Degree:</span> <span class="info-value">${node.degree}</span></div>`;
      if (node.followers !== undefined) html += `<div class="info-row"><span class="info-label">Followers:</span> <span class="info-value">${(node.followers||0).toLocaleString()}</span></div>`;
      if (node.count !== undefined) html += `<div class="info-row"><span class="info-label">Usage:</span> <span class="info-value">${node.count} posts</span></div>`;
      if (node.suspicious) {
        html += `<div class="info-row"><span class="cib-indicator">⚠ SUSPICIOUS ACTIVITY</span></div>`;
        if (node.cibScore) html += `<div class="info-row"><span class="info-label">CIB Score:</span> <span class="cib-score">${node.cibScore}/100</span></div>`;
      }
      if (communities && communities.communities.has(node.id)) {
        const cid = communities.communities.get(node.id);
        html += `<div class="info-row"><span class="info-label">Community:</span> <span class="info-value">#${cid + 1}</span></div>`;
      }
      if (node.verified) html += `<div class="info-row" style="color:#2563eb; font-weight: 600;">✓ Verified</div>`;
      nodeDetails.innerHTML = html;
      nodeInfo.style.display = 'block';
    }
    closeInfo.addEventListener('click', ()=> { nodeInfo.style.display = 'none'; });

    // =========================
    // Communities button
    // =========================
    cibBtn.addEventListener('click', detectCIB);
    
    // CIB Advanced Settings handlers
    cibSettingsBtn.addEventListener('click', () => {
      cibSettingsPanel.style.display = cibSettingsPanel.style.display === 'none' ? 'block' : 'none';
    });
    
    closeCibSettings.addEventListener('click', () => {
      cibSettingsPanel.style.display = 'none';
    });
    
    resetCibParamsBtn.addEventListener('click', () => {
      resetCibParams();
      alert('CIB parameters reset to default values');
    });

    detectBtn.addEventListener('click', () => {
      if (!graphData || graphData.nodes.length === 0) return;
      loading.classList.add('active');
      loadingText.textContent = 'Detecting communities...';
      setTimeout(() => {
        communities = detectCommunities(graphData);
        if (communities) document.getElementById('stat-communities').textContent = communities.count;
        drawNetwork();
        loading.classList.remove('active');
        updateCoach();
      }, 100);
    });

    // =========================
    // Controls wiring
    // =========================
    networkTypeSelect.addEventListener('change', updateNetwork);
    nodeSizeBySelect.addEventListener('change', () => {
      if (nodes.length > 0) drawNetwork();
    });
    engagementFilter.addEventListener('input', (e) => {
      const value = e.target.value; engagementValue.textContent = `${value}+ interactions`;
      updateNetwork();
    });
    dateStart.addEventListener('change', updateNetwork);
    dateEnd.addEventListener('change', updateNetwork);

    exportBtn.addEventListener('click', () => {
      if (!graphData) return;
      const exportData = {
        ...graphData,
        metrics: networkMetrics,
        communities: communities ? { count: communities.count, assignments: Array.from(communities.communities.entries()) } : null,
        cibDetection: cibDetection ? {
          suspiciousUsers: Array.from(cibDetection.suspiciousUsers),
          indicators: cibDetection.indicators,
          userScores: Array.from(cibDetection.userScores.entries()),
          userReasons: Array.from(cibDetection.userReasons.entries())
        } : null
      };
      const dataStr = JSON.stringify(exportData, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url; link.download = `network_analysis_${Date.now()}.json`; link.click();
      URL.revokeObjectURL(url);
    });

    searchInput.addEventListener('input', (e) => {
      const term = e.target.value.toLowerCase();
      if (!term || !nodes.length) { drawNetwork(); return; }
      drawNetwork();
      const matches = nodes.filter(n => (n.label || '').toLowerCase().includes(term));
      
      // Draw search highlights using overlay canvas to avoid context conflicts
      const highlightCanvas = document.createElement('canvas');
      highlightCanvas.width = canvas.width;
      highlightCanvas.height = canvas.height;
      highlightCanvas.style.position = 'absolute';
      highlightCanvas.style.top = '0';
      highlightCanvas.style.left = '0';
      highlightCanvas.style.pointerEvents = 'none';
      highlightCanvas.style.zIndex = '3';
      
      const highlightCtx = highlightCanvas.getContext('2d');
      highlightCtx.strokeStyle = '#ef4444'; 
      highlightCtx.lineWidth = 3;
      matches.forEach(n => { 
        const r = nodeSize(n); 
        highlightCtx.beginPath(); 
        highlightCtx.arc(n.x, n.y, r+3, 0, Math.PI*2); 
        highlightCtx.stroke(); 
      });
      
      // Remove any existing search highlight overlay
      const existingSearchHighlight = canvas.parentNode.querySelector('.search-highlight-overlay');
      if (existingSearchHighlight) {
        existingSearchHighlight.remove();
      }
      
      // Add the search highlight overlay
      highlightCanvas.className = 'search-highlight-overlay';
      canvas.parentNode.appendChild(highlightCanvas);
    });

    window.addEventListener('resize', () => {
      if (graphData && graphData.nodes.length > 0) initializeVisualization();
    });

    // =========================
    // Teaching coach (dynamic)
    // =========================
    function updateCoach() {
      const coach = document.getElementById('edu-coach');
      if (!graphData || !graphData.nodes.length) {
        coach.innerHTML = `<p><b>Guillen</b> load data, then hover or click nodes.</p>`;
        return;
      }
      const dens = networkMetrics?.density ?? 0;
      const commCount = communities?.count ?? 0;

      let hint = '';
      const networkType = networkTypeSelect.value;
      if (networkType === 'coHashtag') {
        hint = `You're looking at hashtag co-occurrence. Dense cliques can reflect coordinated messaging or just memes — check example posts in the modal.`;
      } else if (networkType === 'userHashtag') {
        hint = `This is a bipartite user↔hashtag graph. Click a hashtag hub: who uses it? One community or many?`;
      } else if (networkType === 'mention') {
        hint = `Mention networks highlight attention-giving. Are hubs amplifying each other, or bridging clusters?`;
      } else if (networkType === 'photoTag') {
        hint = `📷 Instagram photo tag network: see who tags whom in photos. This reveals collaboration and relationship patterns.`;
      } else if (networkType === 'location') {
        hint = `📍 Instagram location network: where are users posting from? Shared locations can indicate coordinated campaigns or events.`;
      } else {
        hint = `Hashtag usage view shows which tags carry engagement; hubs suggest narrative anchors.`;
      }

      const densNote = (parseFloat(dens) >= 0.15)
        ? `High density (${dens}) ⇒ tight interlinking. Inspect hubs for templated captions or synchronized timing.`
        : `Lower density (${dens}) ⇒ fragmented/diverse activity. Look for bridges and outliers.`;

      const commNote = commCount
        ? `Detected <b>${commCount}</b> community${commCount>1?'ies':''}. Compare top tags/posts across them for narrative splits.`
        : `Run “Detect Communities” to see sub-audiences.`;

      coach.innerHTML = `
        <p><b>Guillen:</b> ${hint}</p>
        <p>${densNote}</p>
        <p>${commNote}</p>
      `;
    }
  </script>

  <!-- Help Modal -->
  <div id="help-modal" class="help-modal">
    <div class="help-content" onclick="event.stopPropagation()">
      <div class="help-header">
        <div class="help-title">📚 SchuimSurfer User Guide</div>
        <button class="help-close" id="help-close">✕</button>
      </div>
      <div class="help-body" id="help-body">
        <!-- README content will be loaded here -->
        <p style="text-align: center; color: #6b7280;">Loading guide...</p>
      </div>
    </div>
  </div>

  <script>
    // Help Modal functionality
    const helpBtn = document.getElementById('help-btn');
    const helpModal = document.getElementById('help-modal');
    const helpClose = document.getElementById('help-close');
    const helpBody = document.getElementById('help-body');

    // Simple markdown to HTML converter (basic features)
    function markdownToHtml(md) {
      let html = md;
      
      // Headers
      html = html.replace(/^### (.*$)/gim, '<h3>$1</h3>');
      html = html.replace(/^## (.*$)/gim, '<h2>$1</h2>');
      html = html.replace(/^# (.*$)/gim, '<h1>$1</h1>');
      html = html.replace(/^#### (.*$)/gim, '<h4>$1</h4>');
      
      // Bold
      html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
      
      // Italic  
      html = html.replace(/\*(.*?)\*/g, '<em>$1</em>');
      
      // Code inline
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      
      // Links
      html = html.replace(/\[([^\]]+)\]\(([^\)]+)\)/g, '<a href="$2">$1</a>');
      
      // Horizontal rules
      html = html.replace(/^---$/gim, '<hr>');
      
      // Lists (basic)
      html = html.replace(/^\- (.*$)/gim, '<li>$1</li>');
      html = html.replace(/^(\d+)\. (.*$)/gim, '<li>$2</li>');
      
      // Wrap consecutive <li> in <ul>
      html = html.replace(/(<li>.*<\/li>\n?)+/g, function(match) {
        return '<ul>' + match + '</ul>';
      });
      
      // Paragraphs
      html = html.split('\n\n').map(para => {
        para = para.trim();
        if (!para) return '';
        if (para.startsWith('<h') || para.startsWith('<ul') || para.startsWith('<hr') || para.startsWith('<pre')) {
          return para;
        }
        return '<p>' + para + '</p>';
      }).join('\n');
      
      // Code blocks
      html = html.replace(/```(\w+)?\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
      
      return html;
    }

    // Load README content
    async function loadReadme() {
      try {
        const response = await fetch('README.md');
        const markdown = await response.text();
        const html = markdownToHtml(markdown);
        helpBody.innerHTML = html;
      } catch (error) {
        console.error('Failed to load README:', error);
        helpBody.innerHTML = `
          <h1>SchuimSurfer User Guide</h1>
          <p><strong>Unable to load README.md file.</strong> Please ensure README.md is in the same directory as this HTML file.</p>
          <h2>Quick Start</h2>
          <p>1. Upload your social media data (JSON format)<br>
          2. Select network type from dropdown<br>
          3. Click "Detect Communities" to identify clusters<br>
          4. Click "Detect Coordinated Behavior" to run CIB analysis<br>
          5. Click nodes to see details</p>
          <h2>CIB Detection Methods</h2>
          <ul>
            <li>🤖 <strong>Semantic Similarity</strong> - AI-powered caption matching</li>
            <li>⏱️ <strong>Synchronized Posting</strong> - Coordinated timing detection</li>
            <li>🏷️ <strong>TF-IDF Hashtags</strong> - Rare hashtag combinations</li>
            <li>👤 <strong>Username Patterns</strong> - Similar account names</li>
            <li>📈 <strong>Z-Score Analysis</strong> - Statistical outlier detection</li>
            <li>💥 <strong>Temporal Bursts</strong> - Activity spikes</li>
            <li>🎵 <strong>Posting Rhythm</strong> - Bot-like regularity</li>
            <li>🌙 <strong>24/7 Activity</strong> - No sleep gaps</li>
            <li>📝 <strong>N-gram Templates</strong> - Caption templates</li>
            <li>🏭 <strong>Account Clustering</strong> - Batch creation detection</li>
          </ul>
          <h2>Advanced Settings</h2>
          <p>Click "Advanced CIB Settings" to fine-tune detection parameters:</p>
          <ul>
            <li><strong>Semantic Similarity</strong> (0.85) - AI caption threshold</li>
            <li><strong>N-gram Overlap</strong> (0.3) - Template detection</li>
            <li><strong>Username Similarity</strong> (0.8) - Name matching</li>
            <li><strong>TF-IDF Threshold</strong> (0.5) - Rare hashtag sensitivity</li>
            <li><strong>Z-Score Threshold</strong> (2) - Volume outliers</li>
            <li><strong>Burst Min Posts</strong> (5) - Burst trigger</li>
            <li><strong>Rhythm CV</strong> (0.1) - Regularity threshold</li>
            <li><strong>Night Gap</strong> (7200s) - 24/7 detection</li>
            <li><strong>Cluster Size</strong> (5) - Account creation groups</li>
            <li><strong>Cross-Indicator Bonus</strong> (0.3) - Score multiplier</li>
          </ul>
          <h2>Important Notes</h2>
          <p><strong>⚠️ These are indicators, not proof.</strong> Always verify findings manually and consider context.</p>
          <p><strong>Privacy:</strong> All processing happens in your browser. No data is sent to servers.</p>
          <p><strong>Legitimate Coordination:</strong> Activist campaigns, fan communities, and event promotions may trigger detection. Context matters!</p>
        `;
      }
    }

    // Open modal
    helpBtn.addEventListener('click', () => {
      helpModal.classList.add('active');
      if (helpBody.innerHTML.includes('Loading guide')) {
        loadReadme();
      }
    });

    // Close modal
    helpClose.addEventListener('click', () => {
      helpModal.classList.remove('active');
    });

    // Close on overlay click
    helpModal.addEventListener('click', () => {
      helpModal.classList.remove('active');
    });

    // Prevent closing when clicking content
    document.querySelector('.help-content').addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Close on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && helpModal.classList.contains('active')) {
        helpModal.classList.remove('active');
      }
    });
  </script>
</body>
</html>
